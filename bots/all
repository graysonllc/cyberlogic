import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def get_exchange():
	
	#Read in our apikeys and accounts
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	conf=config['binance']
	
	binance_api_key=config['binance']['API_KEY']
	binance_api_secret=config['binance']['API_SECRET']
	
	exchange = ccxt.binance({
    'apiKey': binance_api_key,
    'secret': binance_api_secret,
    'enableRateLimit': True,
    'rateLimit': 3600,
    'verbose': False,  # switch it to False if you don't want the HTTP log
	})
	return(exchange)

exchange=get_exchange()	

def broadcast(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content

def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)
   

def fetch_last_order(exchange,symbol):
	ret=exchange.fetch_closed_orders (symbol, 1,"");
	#print(ret)
	if ret:
		data=ret[-1]['info']
		side=data['side']
		price=data['price']
		print("returning: 1")
	else:
		print("returning: 0")
		data=0
	return data

def die():
	sys.exit("fuck")

def get_price(pair,start_ts,end_ts):

	p=0
	#try:
	start_ts=start_ts+"000"
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&startTime="+str(start_ts)+"&interval=1m"
	print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	print(status)
	rsi_status=''
	print(res)
	trades = json.loads(res.decode('utf-8'))
	data=trades[0]
	price=float(data[4])
	return(price)
	#except:
	#	p=1

def diff_percent(low,high):
	prices = [low,high]
	for a, b in zip(prices[::1], prices[1::1]):
		pdiff=100 * (b - a) / a
	pdiff=round(pdiff,2)

	return(pdiff)

def mojo(pair,price_now):

	mc = memcache.Client(['127.0.0.1:11211'], debug=0)

	blank=1
	
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	key=str(pair)+str("pkey-1hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_1hour = ts_now - datetime.timedelta(seconds=3600)
	ts_1hour_ts=int(time.mktime(ts_1hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_1hour_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_1_hours_ago=get_price(pair,str(ts_1hour_ts),str(ts_now_ts))
	if price_1_hours_ago:
		price_1_hours_ago=float(price_1_hours_ago)
		print("P1HA")
		print(price_1_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_1_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 1 Hour Ago "+str(tsd)+" : "+str(price_1_hours_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-3hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_3hour = ts_now - datetime.timedelta(seconds=10800)
	ts_3hour_ts=int(time.mktime(ts_3hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_3hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_3_hours_ago=get_price(pair,str(ts_3hour_ts),str(ts_now_ts))
	if price_3_hours_ago:
		price_3_hours_ago=float(price_3_hours_ago)
		print("P3HA")
		print(price_3_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_3_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 3 Hour Ago: "+str(tsd)+" : "+str(price_3_hours_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-6hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_6hour = ts_now - datetime.timedelta(seconds=21600)
	ts_6hour_ts=int(time.mktime(ts_6hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_6hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_6_hours_ago=get_price(pair,str(ts_6hour_ts),str(ts_now_ts))
	if price_6_hours_ago:
		price_6_hours_ago=float(price_6_hours_ago)
		print("P6HA")
		print(price_6_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_6_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" "+str(price_now)+" 6 Hour Ago: "+str(tsd)+" : "+str(price_6_hours_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-12hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_12hour = ts_now - datetime.timedelta(seconds=43200)
	ts_12hour_ts=int(time.mktime(ts_12hour.timetuple()))

	tsd=datetime.datetime.fromtimestamp(ts_12hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_12_hours_ago=get_price(pair,str(ts_12hour_ts),str(ts_now_ts))
	if price_12_hours_ago:
		price_12_hours_ago=float(price_12_hours_ago)
		
		print("P12HA")
		print(price_12_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_12_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 12 Hour Ago: "+str(tsd)+" : "+str(price_12_hours_ago)+" Diff %: "+str(price_diff))
	#except:
	#	print("")
	#sys.exit("Die")

def get_rsi(pair,interval):

	arr = []
	out = []
	fin = []
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&interval="+interval+"&limit=500"
	print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	print("Status: "+str(status))
	rsi_status=''
	print("DBRSI: "+str(res))
	trades = json.loads(res.decode('utf-8'))

	lp=0
	for trade in trades:
		open_price=float(trade[0])
		close_price=float(trade[4])
		high_price=float(trade[2])
		low_price=float(trade[3])
		if close_price>0 and close_price!=lp:
			arr.append(close_price)	
		lp=close_price

	np_arr = np.array(arr,dtype=float)
	output=talib.RSI(np_arr,timeperiod=15)

	for chkput in output:
		if chkput>0:
			fin.append(chkput)
		
	rsi=float(fin[-1])
	rsi=round(rsi)
	return(rsi)

def fetch_order_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def main():
	
	from datetime import date
	tickers=exchange.fetchTickers()
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)
	for coin in tickers:

		first=0
		skip=1
		broadcast_message=0
		price_jump=0
		coin=str(coin)
		rsi=100
		btc_price=float(tickers['BTC/USDT']['close'])
		btc_percent=float(tickers['BTC/USDT']['percentage'])

		symbol=tickers[coin]['info']['symbol']
		csymbol=coin
		csymbol=csymbol.replace("/","_",1)
		det=int(0)
		today = str(date.today())
		
		if 'USDT' in symbol:
			min_vol=1000000
			skip=0
		elif 'BTC' in symbol:
			min_vol=500
			skip=0
		elif 'BNB' in symbol:
			min_vol=50000
			
		key = str(date.today())+str('ALERTS-LAST_PRICE')+str(csymbol)
		
		last_price=0
		if mc.get(key):
			last_price=mc.get(key)
			#print("ALERTS DB: GOT LP: "+str(last_price))
		else:
			first=1
			
		data=str()
		row=tickers[coin]
		symbol=row['info']['symbol']
		close=row['close']
		percent=row['percentage']
		low=row['low']
		high=row['high']
		qv=row['quoteVolume']
		price=close
		dprint=1
		pair=symbol
		our_percent=0
		last_price=0
		
		if skip!=1 and qv >=min_vol:
			
			prices = [low,high]
			for a, b in zip(prices[::1], prices[1::1]):
				pdiff=100 * (b - a) / a
			
			pdiff=round(pdiff,2)
				
			spread=pdiff

			pair=symbol

			if last_price>0:
				print("DBLP: "+str(last_price))
				print("PRICE: "+str(price))
				darr = [last_price,price]
				for a, b in zip(darr[::1], darr[1::1]):
					price_jump=100 * (b - a) / a
					price_jump=round(price_jump,2)

			if percent>1 and price_jump>0.10 or percent>1 and first==1:
	
				key = str(date.today())+str('ALERTSDB')+str(csymbol)
				if mc.get(key):
					dprint=2
				else:
					print("ALERTS DEBUG::: LP: "+str(last_price)+" P: "+str(price)+" D: "+str(price_jump))
	
					det=int(1)
					mc.set(key,1,120)
					
					try:
						rsi_3m=get_rsi(symbol,'3m')
						rsi_5m=get_rsi(symbol,'5m')
						rsi_stats="<b>RSI 3M:</b> "+str(rsi_3m)+" <b>RSI 5M:</b> "+str(rsi_5m)
						mojo(symbol,close)
														
						key=str(pair)+str("pkey-1hour")
						if mc.get(key):
							one_hours=mc.get(key)
						else:
							one_hours=0

						key=str(pair)+str("pkey-3hour")
						if mc.get(key):
							three_hours=mc.get(key)
						else:
							three_hours=0
							
						key=str(pair)+str("pkey-6hour")
						if mc.get(key):
							six_hours=mc.get(key)
						else:
							six_hours=0
						
						key=str(pair)+str("pkey-12hour")
						if mc.get(key):
							twelve_hours=mc.get(key)
						else:
							twelve_hours=0
				
						link='https://www.binance.com/en/trade/pro/'+csymbol
						alert_type=':::PRICE ALERT: '+str(percent)+'%:::'					
							
						data_add="<b>1H:</b> "+str(one_hours)+str('%')+", <b>3H:</b> "+str(three_hours)+str('%')+", <b>6H:</b> "+str(six_hours)+"%, <b>12H:</b> "+str(twelve_hours)+str('%')
						data='<b>'+str(symbol)+str(alert_type)+"\nPrice: </b>"+str(close)+' ('+str(percent)+'%)' + "\n<b>Spread:</b> "+str(pdiff)+"%\n<b>BTC Price:</b> "+str(btc_price)+' ('+str(btc_percent)+'%'+')'+"\n"+str(rsi_stats)+"\n"+str(data_add)+"\n"+str(link)

						timestamp=time.time()
						ts_raw=timestamp
						date_time=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
						date_today=str(date.today())							
						alert_key_all=str(date_today)+'-NALERTS'
						alert_key_symbol=str(date_today)+str(symbol)+'-NALERTS'
						alert_list_today=str(date_today)+'-NALERTLIST'
						symbol_ids=str(symbol)+'-NIDS'
						symbol_hash_detailed=str(symbol)+'-'+str(ts_raw)
								
						data=str(data)+"\n\nThis Alert Was Sent AT: "+str(date_time)+" GMT";
							
						pdata=str(date_time)+"\t"+str(price)+"\t"+str(percent)
						redis_server.rpush(alert_key_all,pdata)
														
						redis_server.sadd(alert_list_today,symbol)

						#Add Unique Timestamp to list for this symbol, will use as identifer for hash later
						redis_server.sadd(symbol_ids,ts_raw)
							
						detail_hash = {"date":str(date_today),
						"date_time":str(date_time), 
						"symbol":str(symbol), 
						"alert_type":str(alert_type), 
						"price":float(price), 
						"percent":float(percent), 
						"high":str(high), 
						"low":str(low), 
						"volume":int(qv),
						"spread":float(spread),
						"rsi_3mins":float(rsi_3m),
						"rsi_5mins":float(rsi_5m),
						"btc_price":str(btc_price),
						"btc_percent":str(btc_percent),
						"link":str(link),
						}
		
						print("Writing detailed alert hash data to: "+str(symbol_hash_detailed))
						print(detail_hash)
						redis_server.hmset(symbol_hash_detailed, detail_hash)

						print("Pushing coin to todays alert list: "+str(symbol))
						print(data)

						key = str(date.today())+str('ALERTS-LAST_PRICE')+str(csymbol)
						mc.set(key,price,86400)

						#broadcast('693711905',data)	
						#broadcast('420441454',data)	
						#broadcast('446619309',data)	
						#broadcast('490148813',data)	
						#broadcast('110880375',data)	
						#broadcast('699448304',data)	
						#broadcast('593213791',data)	
						#broadcast('506872080',data)	
						#broadcast('543018578',data)
						#broadcast('503482955',data)
						time.sleep(10)	
						#broadcast('429640253',data)
					except:
						print("threw error")
						time.sleep(5)
				
while True:
	#try:
	main()
	#except:
	#print("error")
	time.sleep(5)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail	

def gotbot(symbol):
	
	redis_server = redis.Redis(host='localhost', port=6379, db=0)
	botlist=redis_server.smembers("botlist")
	
	seen=0
	for bot in botlist:
		bot=bot.decode('utf-8')
		if bot==symbol:
			seen=1
	return(seen)
	
def broadcast_moon(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['MOON_TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content	

def broadcast(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content
	print(html)
	
def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)
   

def fetch_last_order(exchange,symbol):
	ret=exchange.fetch_closed_orders (symbol, 1,"");
	if ret:
		data=ret[-1]['info']
		side=data['side']
		price=data['price']
		#print("returning: 1")
	else:
		#print("returning: 0")
		data=0
	return data

def die():
	sys.exit("fuck")

def get_price(pair,start_ts,end_ts):

	p=0
	#try:
	start_ts=start_ts+"000"
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&startTime="+str(start_ts)+"&interval=1m&limit=100"
	print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))
	data=trades[0]
	price=float(data[4])
	return(price)
	#except:
	#	p=1

def diff_percent(low,high):
	if high>0:
		prices = [low,high]
		for a, b in zip(prices[::1], prices[1::1]):
			pdiff=100 * (b - a) / a
			pdiff=round(pdiff,2)
		return(pdiff)
	else:
		return("")

def get_sentiment(symbol):
	
	exchange=nickbot.get_exchange()	
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	

	ts_5mins = ts_now - datetime.timedelta(seconds=300)
	ts_5mins_ts=int(time.mktime(ts_5mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_5mins_ts).strftime("%Y-%m-%d %H:%M:%S")

	buys=0
	sells=0
	total=0
	slast_price=0
	price_up=0
	price_down=0

	trades=exchange.fetchTrades (symbol)
	for trade in trades:
		side=trade['side']
		sprice=float(trade['info']['p'])

		if side=='buy':
			buys+=1
		else:
			sells+=1

		if slast_price>0 and sprice>slast_price:
			price_up+=1
	
		if slast_price>0 and sprice<slast_price:
			price_down+=1		

		slast_price=sprice
		total+=1	
	
	trade_total=price_up+price_down
	price_up_ratio=100-abs(diff_percent(trade_total,price_up))
	price_down_ratio=100-abs(diff_percent(trade_total,price_down))
	buy_ratio=100-abs(diff_percent(total,buys))
	sell_ratio=100-abs(diff_percent(total,sells))

	sell_ratio=round(sell_ratio,2)
	buy_ratio=round(buy_ratio,2)

	redis_server.set('SENT-BUYS',str(buy_ratio))
	redis_server.set('SENT-SELLS',str(sell_ratio))
	redis_server.set('SENT-PRICE-UP-RATIO',str(price_up_ratio))

	dat="\n<b>:::SENTIMENT DATA:::\nBUYS:</b> "+str(buys)+' ('+str(buy_ratio)+'%)\n<b>SELLS:</b> '+str(sells)+' ('+str(sell_ratio)+'%)'+"\n"+'<b>PRICE UP RATIO:</b> '+str(price_up)+' ('+str(price_up_ratio)+'%)'
	return(dat)

def our_prices(pair,price_now):

	redis_key=str(pair)+str("price-1mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,60,price_now)
		
	redis_key=str(pair)+str("price-3mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,180,price_now)
		
	redis_key=str(pair)+str("price-5mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,300,price_now)

	redis_key=str(pair)+str("price-10mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,600,price_now)
		
	redis_key=str(pair)+str("price-15mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,900,price_now)
	
	redis_key=str(pair)+str("price-30mins")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,1800,price_now)

	redis_key=str(pair)+str("price-1hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,3600,price_now)
	
	redis_key=str(pair)+str("price-2hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,7200,price_now)	
	
	redis_key=str(pair)+str("price-3hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,10800,price_now)
		
	redis_key=str(pair)+str("price-6hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,21600,price_now)

	redis_key=str(pair)+str("price-12hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,43200,price_now)

	redis_key=str(pair)+str("price-24hour")
	if redis_server.get(redis_key):
		g=int(1)
	else:
		redis_server.setex(redis_key,86400,price_now)

def get_rsi(pair,interval):

	arr = []
	out = []
	fin = []
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&interval="+interval+"&limit=500"
	#print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	#print("Status: "+str(status))
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))

	lp=0
	for trade in trades:
		open_price=float(trade[0])
		close_price=float(trade[4])
		high_price=float(trade[2])
		low_price=float(trade[3])
		if close_price>0 and close_price!=lp:
			arr.append(close_price)	
		lp=close_price

	np_arr = np.array(arr,dtype=float)
	output=talib.RSI(np_arr,timeperiod=15)

	for chkput in output:
		if chkput>0:
			fin.append(chkput)
		
	rsi=float(fin[-1])
	rsi=round(rsi)
	return(rsi)

def fetch_order_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def main():
	
	exchange=nickbot.get_exchange()
	
	from datetime import date
	tickers=exchange.fetchTickers()
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)
	for coin in tickers:
		
		first=0
		skip=1
		broadcast_message=0
		price_jump=0
		coin=str(coin)
		rsi=100
		errors=0
		btc_price=float(tickers['BTC/USDT']['close'])
		btc_percent=float(tickers['BTC/USDT']['percentage'])
		last_price=0
		symbol=tickers[coin]['info']['symbol']
		print("SDBS: "+str(coin))
		csymbol=coin
		csymbol=csymbol.replace("/","_",1)
		det=int(0)
		today = str(date.today())
		data=str()
		row=tickers[coin]
		symbol=row['info']['symbol']
		close=row['close']
		percent=row['percentage']
		low=row['low']
		high=row['high']
		qv=row['quoteVolume']
		price=close
		dprint=1
		pair=symbol
		our_percent=0
		rsi_3m=0
		rsi_5m=0
		price_jump=0
		alerts=""
		
		#if 'USD' in symbol:
		#	min_vol=1000000
		#	skip=0
		#e#lif 'PAX' in symbol:
		#	min_vol=1000000
		#	skip=0
		#lif 'BTC' in symbol:
		#	min_vol=500
		#	skip=0
		#elif 'BNB' in symbol:
		#	min_vol=50000
		#	skip=0
		#elif 'ETH' in symbol:
		#	min_vol=1000	
		#	skip=0
		#	
		#if symbol=='BTC/PAX':
		#	skip=0
		vol24=float(nickbot.v24_usd_alerts_cached(exchange,coin,qv))
		vol24=round(vol24,2)

		if vol24>5000000:
			skip=0
		else:
			skip=1
			print(symbol+" VOL TO LOW: "+str(vol24))
			timetrades=float(nickbot.trade_time(exchange,coin))
			if timetrades>60:
				print(str(symbol)+"TRADES TOOK TO LONG")
				skip=1
			else:
				print(symbol+" VOL TO LOW: "+str(vol24))
				skip=1
		#skip=0
		if 'BCHSV' in symbol:
			continue
			
		if low==0 or high==0:
			print("Skipping LH")
			continue
		print(symbol)
		
		#our_prices(symbol,price)
		
		redis_key="ASLASTPRICE-"+symbol+str(date.today())
		if redis_server.get(redis_key):
			last_price=float(redis_server.get(redis_key))
			first=0
			darr = [last_price,price]
			for a, b in zip(darr[::1], darr[1::1]):
				price_jump=100 * (b - a) / a
				price_jump=round(price_jump,2)
		else:
			first=1
		
		prices = [low,high]
		for a, b in zip(prices[::1], prices[1::1]):
			pdiff=100 * (b - a) / a
			
		pdiff=round(pdiff,2)
				
		spread=pdiff
			
		nickbot.log_binance(symbol,price,percent,spread,low,high,qv,btc_price,btc_percent)

		print("DBPercent: "+str(percent)+" Price jump: "+str(price_jump)+" Price: "+str(price)+" Last Price: "+str(last_price)+" BTC PRICE: "+str(btc_price)+" BTC PER: "+str(btc_percent))
			
		if skip!=1:
			
			pair=symbol
			
			#if percent>1 and last_price>0 and price_jump>0.01 and price>last_price or percent>1 and first==1:
						
			if float(percent)>1 and float(last_price)>0 and float(price)>last_price or float(percent)>1 and first==1:

				prices=nickbot.store_prices(symbol,price,volume)
				price_1min=prices['price-1min']
				percent_1min=prices['price-percent-1min']

				price_2min=prices['price-2min']
				percent_2min=prices['price-percent-2min']
					
				price_3min=prices['price-3min']
				percent_3min=prices['price-percent-3min']
		
				price_5min=prices['price-5min']
				percent_5min=prices['price-percent-5min']
	
				price_10min=prices['price-10min']
				percent_10min=prices['price-percent-10min']
	
				price_15min=prices['price-15min']
				percent_15min=prices['price-percent-15min']
	
				price_30min=prices['price-30min']
				percent_30min=prices['price-percent-30min']
					
				price_1hour=prices['price-1hour']
				percent_1hour=prices['price-percent-1hour']

				price_3hour=prices['price-3hour']
				percent_3hour=prices['price-percent-3hour']
		
				price_6hour=prices['price-6hour']
				percent_6hour=prices['price-percent-6hour']
	
				price_12hour=prices['price-12hour']
				percent_12hour=prices['price-percent-12hour']
	
				price_24hour=prices['price-24hour']
				percent_24hour=prices['price-percent-24hour']

				print("ALERTS DEBUG::: LP: "+str(last_price)+" P: "+str(price)+" D: "+str(price_jump))
	
				key = str(date.today())+str('ALERTSDBN2')+str(csymbol)
				if mc.get(key):
					#print("Seen Ignoring it")
					dprint=2
				else:	
					det=int(1)
					mc.set(key,1,60)
					
					try:
						rsi_3m=get_rsi(symbol,'3m')
						rsi_5m=get_rsi(symbol,'5m')
						rsi_stats="<b>RSI 3M:</b> "+str(rsi_3m)+" <b>RSI 5M:</b> "+str(rsi_5m)
					except:
						print("Rsi is the issue")
						errors=1					
					volume=qv
								
					#Lets log the price every 60 seconds to look for jumps
					redis_key="ASLASTPRICE-"+symbol+str(date.today())
					if redis_server.get(redis_key):
						last_price=redis_server.get(redis_key)
						
					if errors==0 and float(price)>float(last_price) or errors==0 and first==1:
						
						redis_key="ASLASTPRICE-"+symbol+str(date.today())
						redis_server.set(redis_key,price)
											
						link='https://www.binance.com/en/trade/pro/'+csymbol
						alert_type=' PRICE ALERT: '+str(percent)+'%:::'					
						
						data_add="<b>1M:</b> "+str(percent_1min)+str('%')+",<b>2M:</b> "+str(percent_2min)+str('%')+",<b>3M:</b> "+str(percent_3min)+str('%')+",<b>5M:</b> "+str(percent_5min)+str('%')+",<b>10M:</b> "+str(percent_10min)+str('%')+",<b>15M:</b> "+str(percent_15min)+str('%')+",<b>30M:</b> "+str(percent_30min)+str('%')+",<b>1H:</b> "+str(percent_1hour)+str('%')+",<b>3H:</b> "+str(percent_3hour)+str('%')+",<b>6H:</b> "+str(percent_6hour)+str('%')+",<b>12H:</b> "+str(percent_12hour)+str('%')+",<b>24H:</b> "+str(percent_24hour)+str('%')

						data='<b>:::'+str(symbol)+str(alert_type)+"\nPrice: </b>"+str(close)+' ('+str(percent)+'%)'+"\n<b>Volume 24H: </b>"+str(vol24) + "\n<b>Spread:</b> "+str(pdiff)+"%\n<b>BTC Price:</b> "+str(btc_price)+' ('+str(btc_percent)+'%'+')'+"\n"+str(rsi_stats)+"\n"+str(data_add)+"\n"+str(link)

						timestamp=time.time()
						ts_raw=timestamp
						date_time=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
						date_today=str(date.today())							
						alert_key_all=str(date_today)+'-NALERTddsSKdNNBNS'+str(symbol)
						alert_list_today=str(date_today)+'-ALERTLIST'

						symbol_ids=str(symbol)+'-IDS'
						symbol_hash_detailed=str(symbol)+'-'+str(ts_raw)
						
						a=0
						lp=0
								
						alerts=redis_server.lrange(alert_key_all,0,1000)
												
						adata=""
						
						for alert in alerts:
							alert=alert.decode('utf-8')
							vDate, vPrice, vPer = alert.split("\t")
							if float(vPrice)>float(lp):
								adata=adata+"\n"+str(vDate)+"\t<b>"+str(vPrice)+"</b>\t<b>"+str(vPer)+"</b>"							
								lp=vPrice
							a=1
						
						alerts_key=str(symbol)+str(date_today)+'-ALERTCYCLES'
						alerts_today=redis_server.incr(alerts_key)

						alerts_key_rolling=str(symbol)+'-ALERTS30MINS'
						if redis_server.get(alerts_key_rolling):
							alerts_30mins=redis_server.incr(alerts_key_rolling)
						else:
							redis_server.setex(alerts_key_rolling,1800,1)
							alerts_30mins=1
													
						alerts_key_rolling=str(symbol)+'-ALERTS1HOUR'
						if redis_server.get(alerts_key_rolling):
							alerts_1hour=redis_server.incr(alerts_key_rolling)
						else:
							redis_server.setex(alerts_key_rolling,3600,1)
							alerts_1hour=1

						alerts_key_rolling=str(symbol)+'-ALERTS2HOUR'
						if redis_server.get(alerts_key_rolling):
							alerts_2hour=redis_server.incr(alerts_key_rolling)
						else:
							redis_server.setex(alerts_key_rolling,7200,1)
							alerts_2hour=2
						
						#Lets also make a memcache # of alerts so we can have auto expiry time, lets set expiry to two hours "7200 seconds rolling"
						mckey=str(pair)+str("MCALERTS")
						mc.incr(mckey,10800)
						
						grab_mc_counter=0
						
						if mc.get(mckey):
							grab_mc_counter=mc.get(mckey)

						moon=0
						if grab_mc_counter>=5 and percent>3 and fifteen_mins>2:
							mooning=str(symbol)+'-MOONING'
							moon=1
							
						sent=get_sentiment(coin)
						data=data+"\n"+str(sent)
						
						pdata=str(date_time)+"\t"+str(price)+"\t"+'('+str(percent)+'%)'

						if a==1:
							data=data+"\n\n<b>TODAYS ALERTS:</b>\n"+str(adata)+"\n"+str(pdata)
						else:
							data=data+"\n\n<b>TODAYS ALERTS:</b>\n"+str(pdata)
						data=str(data)+"\n\n<b>ALERTS TODAY:</b> "+str(alerts_today)

						data=str(data)+"\n\nThis Alert Was Sent AT: "+str(date_time)+" GMT";
						
						
						sent_buys_percent=float(redis_server.get('SENT-BUYS'))
						sent_sells_percent=float(redis_server.get('SENT-SELLS'))
						sent_price_up_ratio=float(redis_server.get('SENT-PRICE-UP-RATIO'))
						
						nickbot.log_alert(symbol,price,percent,spread,sent_buys_percent,sent_sells_percent,sent_price_up_ratio,alerts_today,fifteen_mins,one_hours,three_hours,six_hours,twelve_hours,link)
							
						#print("DBBBBB")
						#print("LP: ")
						#print(last_price)
						#print("DBBBBB:")
						#print(price)
						
						alert_key_nd=str(coin)+'-ALL-ALERTS'
						redis_server.rpush(alert_key_all,pdata)
						redis_server.rpush(alert_key_nd,pdata)
						redis_server.sadd(alert_list_today,symbol)
						
						#Add Unique Timestamp to list for this symbol, will use as identifer for hash later
						redis_server.sadd(symbol_ids,ts_raw)
							
						detail_hash = {"date":str(date_today),
						"date_time":str(date_time), 
						"symbol":str(symbol), 
						"alert_type":str(alert_type), 
						"price":float(price), 
						"percent":float(percent), 
						"high":str(high), 
						"low":str(low), 
						"volume":int(qv),
						"spread":float(spread),
						"rsi_3mins":float(rsi_3m),
						"rsi_5mins":float(rsi_5m),
						"btc_price":str(btc_price),
						"btc_percent":str(btc_percent),
						"link":str(link),
						}
		
						#print("Writing detailed alert hash data to: "+str(symbol_hash_detailed))
						#print(detail_hash)
						redis_server.hmset(symbol_hash_detailed, detail_hash)

						#print("Pushing coin to todays alert list: "+str(symbol))
						#print(data)
						
						#print("DB RED: set "+str(redis_key)+' last_price'+str(price))
						
						#Blacklist from rebuying a coin for 30 minutes
						blacklisted=0
						blacklisted_key=redis_key+"-BLACKLIST"
						
						rk="bconfig-"+symbol
						blacklisted_key=rk+"-BLACKLIST"

						if redis_server.get(blacklisted_key):
							blacklisted=1
	
						alerts_today=float(alerts_today)
						dont_trade=int(1)
						if fifteen_mins>1 and alerts_today>=1 and dont_trade!=1:
							dtoday=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d")
							moonkey=str(dtoday)+'-mooning'
							broadcast_moon('506872080',data)	
							broadcast_moon('446619309',data)
							print("Sent a moon shot alert: key:"+str(moonkey))
							redis_server.sadd(moonkey, symbol)
							
							stable_coin=int(0)
							symbol=symbol.upper()
							ticker_symbol=symbol
							if symbol.endswith('BTC'):
								ticker_symbol = replace_last(ticker_symbol, '/BTC', '')
								trading_to=str('BTC')
							elif symbol.endswith('USDT'):
								ticker_symbol = replace_last(ticker_symbol, '/USDT', '')
								trading_to=str('USDT')
								stable_coin=int(1)
							elif symbol.endswith('BNB'):
								ticker_symbol = replace_last(ticker_symbol, '/BNB', '')
								trading_to=str('BNB')
							elif symbol.endswith('TUSD'):
								ticker_symbol = replace_last(ticker_symbol, '/TUSD', '')
								trading_to=str('TUSD')
							elif symbol.endswith('USD'):
								ticker_symbol = replace_last(ticker_symbol, '/USD', '')
								trading_to=str('USD')
							elif symbol.endswith('USDC'):
								ticker_symbol = replace_last(ticker_symbol, '/USDC', '')
								trading_to=str('USDC')
							elif symbol.endswith('PAX'):
								ticker_symbol = replace_last(ticker_symbol, '/PAX', '')
								trading_to=str('PAX')
								stable_coin=int(1)
							elif symbol.endswith('USDS'):
								ticker_symbol = replace_last(ticker_symbol, '/USDS', '')
								trading_to=str('USDS')
							elif symbol.endswith('ETH'):
								ticker_symbol = replace_last(ticker_symbol, '/ETH', '')
								trading_to=str('ETH')
							trading_from=ticker_symbol
							print("Debug TS: "+str(ticker_symbol))
							#broadcast_moon('506872080',ticker_symbol)	

							moonkey2=str(dtoday)+'-mooning-np'
							redis_server.sadd(moonkey2, ticker_symbol)

							max_bots=10
							#$100 bucks budget per bot
							budget=100
							#Lets Work out the number of units here
							bankinfo=nickbot.work_units(coin,budget)
							units=float(bankinfo["units"])
							balance_needed=float(bankinfo["balance_needed"])
							#Lets check the whole bank roll to see if we got enuff dough for the trade
							balances=exchange.fetch_balance ()
							bank_balance=float(format(balances[trading_to]['total'],'.8f'))
							if bank_balance>=balance_needed and stable_coin==1:
								
								#lets check we don't have a bot allready running for this shit and that we didn't exceed max amount of bots
								botlist=redis_server.smembers("botlist")
								bots_running=int(len(botlist))
								if gotbot(coin)!=1 and bots_running<=max_bots:					
									bcdb='lets spawn an auto trader bot for '+str(coin)+' budget: '+str(budget)+' Units: '+str(units)
									broadcast_moon('506872080',bcdb)
									broadcast_moon('446619309',data)
									rsi_symbol=str(symbol)
									symbol=str(coin)
									buy_pos=int(0)
									sell_pos=int(0)
									stoploss_percent=float(4)
									use_stoploss=int(1)
									candle_size=str('5m')
									safeguard_percent=float(2)
									rsi_buy=float(20)
									rsi_sell=float(80)
									instant_market_buy=str('yes')
									enable_buybacks=str('no')
									enable_safeguard=str('no')
									force_buy=str('yes')
									force_sell=str('no')
									live=str('yes')
									trading_on=str('Binance')
									key=str(symbol)+'-SYSTEM-STOPLOSS'
									if(mc.get(key)):
										mc.delete(key)
									nickbot.auto_spawn(trading_on, rsi_symbol, symbol, units, ticker_symbol, trading_to, buy_pos, sell_pos, stoploss_percent, use_stoploss, candle_size, safeguard_percent, rsi_buy, rsi_sell, instant_market_buy, enable_buybacks, enable_safeguard, force_buy, force_sell, live)
						print("Sending!!!.."+str(data))
						broadcast('506872080',data)	
						broadcast('693711905',data)	
						broadcast('420441454',data)	
						broadcast('446619309',data)	
						broadcast('490148813',data)	
						broadcast('110880375',data)	
						broadcast('699448304',data)	
						broadcast('593213791',data)	
						broadcast('543018578',data)
						broadcast('503482955',data)
						broadcast('429640253',data)
						broadcast('862193134',data)
						
						time.sleep(0.5)	
		
e=0
while True:
	#try:
	main()
	print("Cycle !!!!!\n")
	#except:
	#e=1
	time.sleep(10)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

exchange=nickbot.get_exchange()	

def price_when(symbol,secs):

	symbol=symbol.replace('/','')
	print(symbol)
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	ts_before = ts_now - datetime.timedelta(seconds=secs)
	ts_end = ts_now + datetime.timedelta(seconds=secs)
	print(ts_before)

	ts_before_ts=int(time.mktime(ts_before.timetuple()))
	ts_end_ts=int(time.mktime(ts_end.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_before_ts).strftime("%Y-%m-%d %H:%M:%S")
	print(tsd)
	p=0
	#try:
	print(ts_before_ts)
	start_ts=str(ts_before_ts)+"000"

	end_ts=str(ts_end_ts)+"000"	
	
	url="https://api.binance.com/api/v1/aggTrades?symbol="+symbol+"&startTime="+str(start_ts)+"&endTime="+str(end_ts)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))
	
	data=trades[0]
	price=data['p']
	#price=float(data[4])
	return(price)

def our_prices(pair,price_now,volume_now):

	redis_key=str(pair)+"-HISTORY"
	ts_now = datetime.datetime.now()
	ts_now=int(time.mktime(ts_now.timetuple()))	
	#print(ts_now)
	ts_now=str(ts_now)
	#print("Setting: "+str(redis_key)+" -> "+str(price_now))
	#print(str(volume_now))
	price_set={}
	store=str(ts_now+':'+str(price_now)+':'+str(volume_now))
	price_set[store]=ts_now
	redis_server.zadd(redis_key,price_set)

	redis_key=str(pair)+str("price-1min")

	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,60,price_now)
		mook=int(10)
	redis_key=str(pair)+str("price-3min")
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,180,price_now)
		
	redis_key=str(pair)+str("price-5min")
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,300,price_now)

	redis_key=str(pair)+str("price-10min")
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,600,price_now)
		
	redis_key=str(pair)+str("price-15min")
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,900,price_now)
	
	redis_key=str(pair)+str("price-30min")
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,1800,price_now)


	redis_key=str(pair)+str("price-1hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,3600,price_now)
	
	redis_key=str(pair)+str("price-2hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,7200,price_now)	
	
	redis_key=str(pair)+str("price-3hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,10800,price_now)
		val=redis_server.get(redis_key)
		#print(str(val))
	redis_key=str(pair)+str("price-6hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,21600,price_now)

	redis_key=str(pair)+str("price-12hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,43200,price_now)

	redis_key=str(pair)+str("price-24hour")
	#redis_server.delete(redis_key)
	
	if redis_server.get(redis_key):
		val=redis_server.get(redis_key).decode('utf-8')
		#print(str(val))
	else:
		redis_server.setex(redis_key,86400,price_now)
				
def main():
	
	from datetime import date
	tickers=exchange.fetchTickers()
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)
	
	for coin in tickers:
		
		first=0
		skip=1
		broadcast_message=0
		price_jump=0
		coin=str(coin)
		rsi=100
		errors=0
		btc_price=float(tickers['BTC/USDT']['close'])
		btc_percent=float(tickers['BTC/USDT']['percentage'])
		last_price=0
		symbol=tickers[coin]['info']['symbol']

		csymbol=coin
		csymbol=csymbol.replace("/","_",1)
		det=int(0)
		today = str(date.today())
		data=str()
		row=tickers[coin]
		symbol=row['info']['symbol']
		close=row['close']
		percent=row['percentage']
		low=row['low']
		high=row['high']
		qv=row['quoteVolume']
		price=close
		#print("COIN: "+str(coin)+" - Price: "+str(price))
		prices=nickbot.store_prices(symbol,price,qv)

	time.sleep(0.5)
		
e=0
while True:
	#try:
	main()
	print("Cycle !!!!!\n")
	#except:
	#e=1
import os
import sys, argparse
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import redis
import configparser
from datetime import datetime
import subprocess
import heapq

r = redis.Redis(host='localhost', port=6379, db=0)

config = configparser.ConfigParser()

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402

def log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low):

	key=str(symbol)+'-SYSTEM-STOPLOSS'
	if mc.get(key):
		stoploss_price=float(mc.get(key))
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	market_price=float(close)
	
	profit_per_unit=market_price-buy_price
	profit=float(profit_per_unit*units)
	profit=round(profit,8)
	prices = [buy_price,market_price]
	for a, b in zip(prices[::1], prices[1::1]):
		profit_percent=100 * (b - a) / a
		profit_percent=round(profit_percent,2)

	total_invest=units*buy_price
	total_now=units*market_price	

	total_now=float(total_now)
	total_now=round(total_now,8)

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = """
		INSERT INTO at_history(date,date_time,timestamp,symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low)
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	"""
	print(sql)
	cursor.execute(sql,(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low))
	db.close()
	
def log_redis(redis_key,message,c):

	if c>10000:
		print(r.lpop(redis_key))
		
	now = datetime.now()
	ts = datetime.timestamp(now)
	running=datetime.fromtimestamp(ts).strftime("%Y-%m-%d %I:%M:%S")

	message=str(running)+"\t"+str(message)
	print("Writing to redis: "+str(redis_key))
	print(message)
	r.rpush(redis_key,message)

def fetch_wall_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def walls(symbol):
	
	symbol=symbol.upper()
	exchange=get_exchange()
	buy_book=fetch_wall_book(exchange,symbol,'bids','500')
	sell_book=fetch_wall_book(exchange,symbol,'asks','500')

	
	buy_dic={}
	sell_dic={}
	
	for k,v in buy_book:
		buy_dic[k]=v

	for k,v in sell_book:
		sell_dic[k]=v
				
	buy_walls=heapq.nlargest(20, buy_dic.items(), key=itemgetter(1))
	sell_walls=heapq.nlargest(20, sell_dic.items(), key=itemgetter(1))
	
	message="<b>INFO:: - "+str(symbol)+"WALL INTEL:</b>\n\n"
	
	message=message+"<b>BUY WALLS ('SUPPORT')</b>\n"
	
	for k,v in sorted(buy_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"

	message=message+"\n<b>SELL WALLS ('RESISTANCE')</b>'\n"
	for k,v in sorted(sell_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"
		
	broadcast(message)

def get_exchange():
	
	#Read in our apikeys and accounts
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	conf=config['binance']
	
	binance_api_key=config['binance']['API_KEY']
	binance_api_secret=config['binance']['API_SECRET']
	
	members=r.smembers("botlist")
	sizeof=len(members)
	throttle=sizeof*1200

	exchange = ccxt.binance({
    'apiKey': binance_api_key,
    'secret': binance_api_secret,
    'enableRateLimit': True,
    'rateLimit': throttle,
    'verbose': False,  # switch it to False if you don't want the HTTP log
	})
	return(exchange)

exchange=get_exchange()

def delete_bot(symbol):
	bot_name=symbol
	r.srem("botlist", bot_name)
	r.delete(bot_name)
	redis_key="bconfig-"+bot_name
	all_keys = list(r.hgetall(redis_key).keys())
	r.hdel(redis_key, "*")	
	config = configparser.ConfigParser()
	config_file='/home/crypto/cryptologic/pid-configs/init.ini'
	config.read(config_file)
	
	bot_section='watcher:'+str(bot_name)
	config.remove_section(bot_section)
	
	for line in config:
		print(line)
	with open(config_file, 'w') as configfile:
	
		print("debug")
		print(config)
		config.write(configfile)
		
		print("Write Config File to: "+str(config_file))
		print("Wrote: "+str(configfile))
	
	subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def broadcast(text):

	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	chatid=config['binance']['TRADES_CHANNEL']
	print(chatid)
	token = telegram_id
	timestamp=time.time()
	date_time=datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
	text="<b>"+str(date_time)+"</b>\t"+str(text)
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+text+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content
	print(html)
	
def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)
   

def fetch_last_order(exchange,symbol):
	print("passed: "+str(symbol))
	ret=exchange.fetch_closed_orders (symbol, 1);
	print(ret)
	if ret:
		
		data=ret[-1]['info']
		side=data['side']
		price=float(data['price'])
		print("returning: 1")
		return data
	else:
		print("returning: 0")
		data=0
		return data

def die():
	sys.exit("fuck")


def get_rsi(pair,interval):

	try:
		arr = []
		out = []
		fin = []
		url="https://api.binance.com/api/v1/klines?symbol="+pair+"&interval="+interval+"&limit=100"
		print(url)
		r=requests.get(url)
		res = (r.content.strip())
		status = r.status_code
		rsi_status=''
		trades = json.loads(res.decode('utf-8'))

		for trade in trades:
			open_price=float(trade[0])
			close_price=float(trade[4])
			high_price=float(trade[2])
			low_price=float(trade[3])
			if close_price>0:
				arr.append(close_price)
			

		np_arr = np.array(arr,dtype=float)
		output=talib.RSI(np_arr,timeperiod=14)

		for chkput in output:
			if chkput>0:
				fin.append(chkput)
		
		rsi=float(fin[-1])
		rsi=round(rsi)
		return(rsi)
	except:
		print("rsi is the problem")
		
def fetch_order_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks
		
def main(exchange,symbol,c):
	
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)

	conn = redis.Redis('127.0.0.1')

	redis_log="LOG-"+symbol
	redis_trade_log="TRADELOG-"+symbol
	redis_key="bconfig-"+symbol
	redis_rsi_log="RSILOG-"+symbol
	ret=0
	trading_on=conn.hget(redis_key,"trading_on")
	trading_on=trading_on.decode('utf-8')
	rsi_symbol=conn.hget(redis_key,"rsi_symbol")
	rsi_symbol=rsi_symbol.decode('utf-8')
	symbol=conn.hget(redis_key,"symbol")
	symbol=symbol.decode('utf-8')
	units=conn.hget(redis_key,"units")
	units=units.decode('utf-8')
	trade_from=conn.hget(redis_key,"trade_from")
	trade_from=trade_from.decode('utf-8')
	trade_to=conn.hget(redis_key,"trade_to")
	trade_to=trade_to.decode('utf-8')
	buy_pos=conn.hget(redis_key,"buy_pos")
	buy_pos=buy_pos.decode('utf-8')	
	sell_pos=conn.hget(redis_key,"sell_pos")
	sell_pos=sell_pos.decode('utf-8')
	stoploss_percent=conn.hget(redis_key,"stoploss_percent")
	stoploss_percent=stoploss_percent.decode('utf-8')
	safeguard_percent=conn.hget(redis_key,"safeguard_percent")
	safeguard_percent=safeguard_percent.decode('utf-8')
	use_stoploss=conn.hget(redis_key,"use_stoploss")
	use_stoploss=use_stoploss.decode('utf-8')
	candle_size=conn.hget(redis_key,"candle_size")
	candle_size=candle_size.decode('utf-8')
	rsi_buy=conn.hget(redis_key,"rsi_buy")
	rsi_buy=rsi_buy.decode('utf-8')
	rsi_sell=conn.hget(redis_key,"rsi_sell")
	rsi_sell=rsi_sell.decode('utf-8')
	live=conn.hget(redis_key,"live")
	live=live.decode('utf-8')
	enable_safeguard=conn.hget(redis_key,"enable_safeguard")
	enable_safeguard=enable_safeguard.decode('utf-8')
	enable_buybacks=conn.hget(redis_key,"enable_buybacks")
	if enable_buybacks:
		enable_buybacks=enable_buybacks.decode('utf-8')
	rsi_sell=float(rsi_sell)
	rsi_buy=float(rsi_buy)
	stoploss_percent=float(stoploss_percent)
	safeguard_percent=float(safeguard_percent)
	use_stoploss=str(use_stoploss)
	if use_stoploss=='1':
		use_stoploss=str('yes')
	units=float(units)
	sell_pos=int(sell_pos)
	buy_pos=int(buy_pos)
	message="Exchange: "+trading_on+"\tExchange: "+trading_on+"\tTrade Pair: "+str(symbol)+"\tUnits: "+str(units)+"\tBuy Book Scrape Position: "+str(buy_pos)+"\tSell Book Scrape Position: "+str(sell_pos)+"\tRSI Buy: "+str(rsi_buy)+"\tRSI Sell: "+str(rsi_sell)+"\tStoploss Percent: "+str(stoploss_percent)+"\tSafeguard Percent: "+str(safeguard_percent)+"\tEnable Safeguard: "+str(enable_safeguard)+"\tCandle Size: "+candle_size+"\tUse Stoploss: "+str(use_stoploss)+"\tLive Trading Enabled: "+live

	if c==0:
		log_redis(redis_log,message,c)
		print(message)

	key=str(symbol)+'-ORIGINAL-SL'	
	r.setex(key,3600,stoploss_percent)

	ignore_rsi=0
	sleep_for_after_stoploss_executed=600
	
	#If the manual bot is doing sell off then dont interfere
	key=str(symbol)+'-PAUSED'	
	if(mc.get(key)):
		#time.sleep(30)
		return(1)
	
	key=str(symbol)+'-SL'	
	if(mc.get(key)):
		ignore_rsi=1
		print("Got Stoploss key\n")
		mc.delete(key)
	
	original_stoploss_price=0
	key=str(symbol)+'-ORIGINAL-STOPLOSS-PRICE'	
	if(mc.get(key)):
		original_stoploss_price=float(mc.get(key))
		print(original_stoploss_price)
		
	exchange_cut=0.007500;
	
	tkey="seen"+str(symbol)
	orders = exchange.fetch_open_orders(symbol,1)
	
	open_order=len(orders)
	
	ticker = exchange.fetch_ticker(symbol.upper())
	bid=float(ticker['bid'])
	last=float(ticker['last'])
	ask=float(ticker['ask'])
	open=float(ticker['open'])
	close=float(ticker['close'])
	high=float(ticker['high'])
	low=float(ticker['low'])
	
	key=str(symbol)+'-LAST-PRICE'	
	#mc.set(key,close,86400)
	r.setex(key,3600,close)

	lo_key="last_order-"+str(symbol)
	if mc.get(lo_key):
		last_array=mc.get(lo_key)
		last_price=float(last_array['price'])
		last_type=last_array['side']
		buy_price=last_price
	else:
		#Cache last order in ram for 60 seconds to speed up api calls
		print("Db: lT: "+str(symbol))
		last_array=fetch_last_order(exchange,symbol)
		if last_array!=0:
			last_price=float(last_array['price'])
			last_type=last_array['side']
			buy_price=last_price
			mc.set(lo_key,last_array,60)
		else:
			last_type='NULL'

	if open_order:
		for order in orders:
			order_symbol=order['info']['symbol']
			if order_symbol==rsi_symbol:
				open_type=order['info']['side']
				open_price=order['price']
				open_filled=order['filled']
				open_remaining=order['remaining']
				open_fee=order['fee']
				order_id=order['info']['orderId']				
				order_timestamp=order['timestamp']/1000
				start_time=order_timestamp
				elapsed = time.time() - start_time
				elapsed=round(elapsed)
				
				message="<b>ALERT:: - "+str(symbol)+" OPEN ORDER\tTYPE:</b> " +str(open_type)+"\n<b>OPEN FOR: </b> "+str(elapsed)+" Seconds\n"+"<b>PRICE:</b> "+str(open_price)+ "\n<b>FILLED:</b> "+str(open_filled)+"/"+str(open_remaining)+"\n<b>ORDER ID:</b> "+str(order_id)+"\t<b>TICKER\tLAST:</b> "+str(last)+" <b>BID:</b> "+str(bid)+" <b>ASK:</b> "+str(ask)
				if open_type=='BUY' and float(elapsed)>1200:
					exchange.cancelOrder(order_id,symbol)
					delete_bot(symbol)		
					message=message+"\n\n<b>CANCELLING ORDER TO MUCH TIME ELAPSED</b>\n"
					broadcast(message)
				
				oo_key=str(symbol)+'-OOssTMPS'	
				if not (mc.get(oo_key)):
					mc.set(oo_key,1,1800)			
					broadcast(message)
					log_redis(redis_log,message,c)
					print(message)
		return("open")

	print("LT: "+str(last_type))
	if use_stoploss=="yes" or use_stoploss==1:
			
		if last_type=='BUY':
					
			stoploss=last_price/100*stoploss_percent
			stoploss_price=last_price-stoploss

			print("Debug SL: "+str(stoploss_percent))
			print("Debug SLP: "+str(stoploss_price))
			print("Debug LP: "+str(last_price))
			print("Debug OSL: "+str(original_stoploss_price))
						
			### ADD SMART STOPLOSS CODE
			key=str(symbol)+'-SYSTEM-STOPLOSS'
			if mc.get(key):
				stoploss_price=float(mc.get(key))
				sell_price=stoploss_price
			else:
				book=fetch_order_book(exchange,symbol,'bids',1)
				sell_price=float(book[0][0])

			message="Last buy price: "+str(last_price)+"\tStoploss price: "+str(stoploss_price)+"\tmarket price: "+str(last)
			log_redis(redis_log,message,c)
			log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low)
			print(message)

			if last <= stoploss_price or last <= original_stoploss_price:

				book=fetch_order_book(exchange,symbol,'bids',1)
				sell_price=float(book[0][0])

				mc.delete(key)
				print("creating stoploss order: "+str(sell_price))
				message="<b>ALERT:: - "+str(symbol)+" STOPLOSS HIT</b>, <b>SELLING:</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(sell_price)+" <b>LAST BUY @:</b>"+str(last_price)
				broadcast(message)
				print(message)
				log_redis(redis_trade_log,message,c)
							
				if live=="yes":
					ret=exchange.create_order (symbol, 'limit', 'sell', units, sell_price)
					broadcast(message)

					message="Killing Bot"
					log_redis(redis_trade_log,message,c)
					if enable_buybacks=='no':
						delete_bot(symbol)			
						print("killing bot/deleting it")	
						return("kill")
						key=str(symbol)+'-SL'	
						mc.set(key,1,86400)			
	else:
				
		rsikey="rsi"+str(symbol)
		rsi=get_rsi(rsi_symbol,candle_size)
		print("RSI")
		print(rsi)
		rsi=float(rsi)
	
		lo_key="last_order-"+str(symbol)
		mc.delete(lo_key)
		if mc.get(lo_key):
			last_array=mc.get(lo_key)
			last_price=float(last_array['price'])
			last_type=last_array['side']
		else:
			#Cache last order in ram for 60 seconds to speed up api calls
			print("Db: lT: "+str(symbol))
			last_array=fetch_last_order(exchange,symbol)
			last_price=float(last_array['price'])
			last_type=last_array['side']
			mc.set(lo_key,last_array,60)
		
		print(last_array)
		if last_price==0.00:
			#Was a market buy so we didn't pass a buy price work it out by cummulativeQuoteQty/aka fee / units
			market_fee=float(last_array['cummulativeQuoteQty'])
			market_units=float(last_array['origQty'])
			last_price=market_fee/market_units
			print("Debug LA: ")
			print(last_price)
			print(last_array)
	
		if last_type=='BUY':
			trade_action='selling'
		else:
			trade_action='buying'

		#Added forcebuy usefull if u wanna force a buy on rsi without instant buy @ market
		fbkey=symbol+"-FORCE-BUY"
		if mc.get(fbkey):
			trade_action='buying'
			mc.delete(fbkey)

		fskey=symbol+"-FORCE-SELL"
		if mc.get(fskey):
			trade_action='selling'
			mc.delete(fskey)

		message="No open orders Currently RSI: "+str(rsi)	
		log_redis(redis_log,message,c)
		print(message)

		if ticker:
			message=str(symbol)+"\t"+str(bid)+"\t"+str(ask)+"\t"+str(last)+"\t"+str(high)+"\t"+str(low)+"\t"+str(rsi)
			log_redis(redis_rsi_log,message,c)
	
		got_key=int(0)
		key=str(symbol)+'-SYSTEM-BUYBACK'
		if mc.get(key):
			got_key=0

		if trade_action=="buying" and rsi<=rsi_buy or trade_action=="buying" and ignore_rsi==1 or trade_action=="buying" and got_key==1:
			
			if use_stoploss=="yes":
				stoploss=last_price/100*stoploss_percent
				stoploss_price=last_price-stoploss
		
				print("Debug: "+str(stoploss_percent))
				print("Last Price: "+str(last_price))
			
				### ADD SMART STOPLOSS CODE
				key=str(symbol)+'-SYSTEM-STOPLOSS'
				if mc.get(key):
					stoploss_price=float(mc.get(key))	
						
				print("last buy price: "+str(last_price))
				print("stoploss price: "+str(stoploss_price))
				print("market price: "+str(last))
					
				message="Last buy price: "+str(last_price)+"\tStoploss price: "+str(stoploss_price)+"\tmarket price: "+str(last)
				log_redis(redis_log,message,c)
				print(message)

				if last <= stoploss_price or last <= original_stoploss_price:		
					mc.delete(key)
					book=fetch_order_book(exchange,symbol,'bids',1)
					sell_price=float(book[0][0])
					print("creating stoploss order: "+str(sell_price))
					message="<b>ALERT:: - "+str(symbol)+" STOPLOSS HIT</b> <b>SELLING:</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(sell_price)+" <b>LAST BUY @:</b>"+str(last_price)
					broadcast(message)
					log_redis(redis_trade_log,message,c)
					if live=="yes":
						ret=exchange.create_order (symbol, 'limit', 'sell', units, sell_price)
							
					if enable_buybacks=='no':
						message="killing script no buyback here :"+str(sleep_for_after_stoploss_executed)+ "seconds now giving market time to adjust our dough is tethered"
						delete_bot(symbol)
						broadcast(message)	
						return("kill")
						
						key=str(symbol)+'-KILL'	
						mc.set(key,1,86400)			
						
						key=str(symbol)+'-SL'	
						mc.set(key,1,86400)	
						
			if enable_safeguard=='yes':
				safeguard=last_price/100*safeguard_percent
				price=last_price-safeguard
			else:
				book=fetch_order_book(exchange,symbol,'bids',1)
				price=float(book[buy_pos][0])
				
			exchange_cut=price/100*0.007500
			price=price-exchange_cut
			print("Making buyorder for "+str(units)+" price: "+str(price)+"\n")	
	
			message="<b>ALERT:: - "+str(symbol)+" BUYING</b> "+str(units)+"UNITS\t<b>BUY @:</b> "+str(price)+"\t<b>LAST SELL @:</b> "+str(last_price)
			log_redis(redis_trade_log,message,c)

			broadcast(message)
			print(ret)
			message="Live Ticker:\nBid: "+str(bid)+" Ask: "+str(ask)+ " Last: "+str(last)+ "\nHigh: "+str(high)+" Low: "+str(low)+"\nOpen: "+str(open)+" Close: "+str(close)+"\n"
			if live=="yes":
				ret=exchange.create_order (symbol, 'limit', 'buy', units, price)
				print(ret)

			log_redis(redis_trade_log,message,c)
			print(message)
		elif trade_action=="selling" and rsi>=rsi_sell:
			book=fetch_order_book(exchange,symbol,'asks',1)
			price=float(book[sell_pos][0])
		
			if price < last_price and enable_safeguard=='yes':
				message=str(price)+" is under: "+str(last_price)
				log_redis(redis_trade_log,message,c)
				safeguard=last_price/100*safeguard_percent
				price=last_price+safeguard
				message="Using safeguard price is now: "+str(price)
				log_redis(redis_trade_log,message,c)
				print(message)
				
			exchange_cut=price/100*0.007500
			price=price+exchange_cut
			
			print("Making sell order for "+str(units)+" price: "+str(price)+"\n")

			message="<b>ALERT:: - "+str(symbol)+" SELLING</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(price)+"\t<b>LAST BUY:</b> "+str(last_price)
			broadcast(message)
			log_redis(redis_trade_log,message,c)

			if live=="yes":
				ret=exchange.create_order (symbol, 'limit', 'sell', units, price)
				print(ret)
			message="\nLive Ticker:\nBid: "+str(bid)+" Ask: "+str(ask)+ " Last: "+str(last)+ "\nHigh:"+str(high)+" Low: "+str(low)+"\nOpen: "+str(open)+" Close: "+str(close)+"\n"
			
			log_redis(redis_trade_log,message,c)
			if enable_buybacks=='no':
				message="killing script no buyback here success sell without stoploss hitting"
				delete_bot(symbol)
				broadcast(message)	
				return("kill")
		
			message="<b>ALERT:: - "+str(symbol)+"</b>\nThe market Conditions are not right for a buy or sell <b>RSI is:</b> "+str(rsi)+" Our next action is -> "+str(trade_action)
			print(message)
			tm_key=str(symbol)+'-TMPS'	
			if not (mc.get(tm_key)):
				mc.set(tm_key,1,600)			
				broadcast(message)
				#walls(symbol)
				log_redis(redis_log,message,c)

		return(1)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

parser = argparse.ArgumentParser()

parser.add_argument('--trading_pair', help='Trading pair i.e BTC/USDT')
args = parser.parse_args()

symbol=str(args.trading_pair)
print(symbol)

if r.sismember('botlist',symbol)==0:
	delete_bot(symbol)			
	sys.exit("bot not in list")
	print("bot not in list")
c=0

message="<b>ALERT:: SPAWNED A NEW BOT FOR: "+str(symbol)+"</b>"
print(message)
#broadcast(message)

while True:
	ret="meh"
	
	#try:
	#print("tying")
	ret=main(exchange,symbol,c)
	#except:
	#print("threw error sleeping for 3 seconds")
	#time.sleep(5)
	
	if ret=="kill":
		print("killing")
		delete_bot(symbol)			
		sys.exit("die")
	c+=1
	time.sleep(0.5)import os
from collections import OrderedDict
import requests
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import talib
import numpy as np
import ccxt
import redis
from datetime import datetime
import configparser
import subprocess
import time
import shlex
import argparse
import heapq
config = configparser.ConfigParser()
config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database='cmc'
telegram_id=config['binance']['TEEGRAM_ID_EMBED']

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')
	
r = redis.Redis(host='localhost', port=6379, db=0)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

def get_exchange():
	
	#Read in our apikeys and accounts
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	conf=config['binance']
	
	binance_api_key=config['binance']['API_KEY']
	binance_api_secret=config['binance']['API_SECRET']
	
	exchange = ccxt.binance({
    'apiKey': binance_api_key,
    'secret': binance_api_secret,
    'enableRateLimit': True,
    'rateLimit': 3600,
    'verbose': False,  # switch it to False if you don't want the HTTP log
	})
	return(exchange)

def spawn_bot(symbol):
	
	config = configparser.ConfigParser()
	
	bfn=str(symbol.lower())+'.ini'
	bfn=bfn.replace("/", "-")
	
	bot_name='watcher:'+str(symbol)
	bot_file='/home/crypto/cryptologic/pid-configs/init.ini'
	args='--trading_pair '+str(symbol)

	#If we allready have this bot in the circus ini don't add it again
	config.read(bot_file)

	if not config.has_section(bot_name):
	
		config.add_section(bot_name)
		config.set(bot_name, 'cmd', '/usr/bin/python3.6 /home/crypto/cryptologic/bots/autotrader.py')
		config.set(bot_name, 'args', args)
		config.set(bot_name, 'warmup_delay', '0')
		config.set(bot_name, 'numprocesses', '1')

		with open(bot_file, 'w') as configfile:
			configfile.write("\n")
			config.write(configfile)
			print("Write Config File to: "+str(bot_file))
			print("Wrote: "+str(configfile))

		subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def fetch_order_book(exchange,symbol,type,qlimit):
	#limit = 1000
	ret=exchange.fetch_l2_order_book(symbol, qlimit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def auto_spawn(trading_on,rsi_symbol, symbol, units, trade_from, trade_to, buy_pos, sell_pos, stoploss_percent, use_stoploss, candle_size, safeguard_percent, rsi_buy, rsi_sell, instant_market_buy, enable_buybacks, enable_safeguard, force_buy, force_sell, live):

	bot_name=symbol

	r = redis.Redis(host='localhost', port=6379, db=0)
	
	bot_config = {"trading_on":str(trading_on),
	"rsi_symbol":str(rsi_symbol), 
	"symbol":str(bot_name), 
	"units":float(units), 
	"trade_from":str(trade_from), 
	"trade_to":str(trade_to), 
	"buy_pos":int(buy_pos),
	"sell_pos":int(sell_pos),
	"stoploss_percent":float(stoploss_percent),
	"use_stoploss":use_stoploss,
	"candle_size":str(candle_size),
	"safeguard_percent":float(safeguard_percent),
	"rsi_buy":float(rsi_buy),
	"rsi_sell":float(rsi_sell),
	"instant_market_buy":str(instant_market_buy),
	"enable_buybacks":str(enable_buybacks),
	"enable_safeguard":str(enable_safeguard),
	"force_buy":str(force_buy),
	"force_sell":str(force_sell),
	"live":str(live)}
	
	all=bot_config
	print(bot_config)
	ksymbol=str(symbol)

	redis_key="bconfig-tmp"
	r.hmset(redis_key, bot_config)
	
	bot_name=symbol
		
	r.sadd("botlist", bot_name)
	timestamp=time.time()

	r.set(symbol,timestamp)
	running=datetime.datetime.fromtimestamp(timestamp).strftime("%A, %B %d, %Y %I:%M:%S")

	timestamp=time.time()
	ts_raw=timestamp
	running=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
			
	redis_key="bconfig-"+symbol
		
	r.hmset(redis_key, all)
	bid=r.incr("bids")
	r.hset(redis_key,"id",bid)

	if force_buy=="yes":
		mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
		key=symbol+"-FORCE-BUY"
		mc.set(key,force_buy,86400)			

	elif force_sell=="yes":
		mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
		key=symbol+"-FORCE-SELL"
		mc.set(key,force_sell,86400)			

	if instant_market_buy=="yes":
		exchange=get_exchange()
		buy_book=fetch_order_book(exchange,symbol,'bids','1000')
		buy_pos=int(buy_pos)
		buy_price=float(buy_book[buy_pos][0])
		print(symbol+" Units Buy Price"+str(buy_price))
		ret=exchange.create_order (symbol, 'limit', 'buy', units, buy_price)
		print(ret)			
	spawn_bot(symbol)

exchange=get_exchange()

symbol='DENT/ETH'
rsi_symbol='DENTETH'
orders = exchange.fetch_open_orders(symbol,1)
open_order=len(orders)

if open_order:
	for order in orders:
		print(order)
		order_symbol=order['info']['symbol']
		
		if order_symbol==rsi_symbol:
			open_type=order['info']['side']
			open_price=order['price']
			open_filled=order['filled']
			open_remaining=order['remaining']
			open_fee=order['fee']
			order_id=order['info']['orderId']
			order_timestamp=order['timestamp']/1000
			start_time=order_timestamp
			elapsed = time.time() - start_time
			
			print("ET: ")
			print(elapsed_time)



sys.exit("die")

rsi_symbol=str('ETHUSDT')
symbol=str('ETH/USDT')
units=float(0.1)
trade_from=str('ETH')
trade_to=str('USDT')
buy_pos=int(20)
sell_pos=int(20)
stoploss_percent=float(4)
use_stoploss=int(1)
candle_size=str('5m')
safeguard_percent=float(2)
rsi_buy=float(20)
rsi_sell=float(80)
instant_market_buy=str('yes')
enable_buybacks=str('no')
enable_safeguard=str('yes')
force_buy=str('yes')
force_sell=str('no')
live=str('yes')
trading_on=str('Binance')

auto_spawn(trading_on, rsi_symbol, symbol, units, trade_from, trade_to, buy_pos, sell_pos, stoploss_percent, use_stoploss, candle_size, safeguard_percent, rsi_buy, rsi_sell, instant_market_buy, enable_buybacks, enable_safeguard, force_buy, force_sell, live)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def main(symbol,stop_units,stop_add,decrease_per,increase_per,stoploss_percent):

	increase_per=float(increase_per)
	decrease_per=float(decrease_per)
	exchange=nickbot.get_exchange()
	ticker = exchange.fetch_ticker(symbol.upper())
	pair=symbol
	bid=float(ticker['bid'])
	last=float(ticker['last'])
	ask=float(ticker['ask'])
	open=float(ticker['open'])
	close=float(ticker['close'])
	high=float(ticker['high'])
	low=float(ticker['low'])
	volume=float(ticker['quoteVolume'])
	price=close
	stop_add=float(stop_add)
	stop_action=int(0)
	price_last=int(0)
	redis_key=str(pair)+str("price-last")	
	
	if redis_server.get(redis_key):
		price_last=redis_server.get(redis_key).decode('utf-8')
		price_last=float(price_last)
	redis_server.set(redis_key,price)
	
	print("Price Now: "+str(price))
	print("Price Last: "+str(price_last))
	print("Stored Symbol: "+str(symbol))
	prices=nickbot.store_prices(symbol,price,volume)
	print(prices)
	price_1min=prices['price-1min']
	percent_1min=prices['price-percent-1min']

	price_2min=prices['price-2min']
	percent_2min=prices['price-percent-2min']

	price_3min=prices['price-3min']
	percent_3min=prices['price-percent-3min']
		
	price_5min=prices['price-5min']
	percent_5min=prices['price-percent-5min']
	
	price_10min=prices['price-10min']
	percent_10min=prices['price-percent-10min']
	
	price_15min=prices['price-15min']
	percent_15min=prices['price-percent-15min']
		
	price_30min=prices['price-30min']
	percent_30min=prices['price-percent-30min']
	
	price_1hour=prices['price-1hour']
	percent_1hour=prices['price-percent-1hour']

	price_2hour=prices['price-2hour']
	percent_2hour=prices['price-percent-2hour']
	
	price_3hour=prices['price-3hour']
	percent_3hour=prices['price-percent-3hour']
		
	price_6hour=prices['price-6hour']
	percent_6hour=prices['price-percent-6hour']
	
	price_12hour=prices['price-12hour']
	percent_12hour=prices['price-percent-12hour']
	
	price_24hour=prices['price-24hour']
	percent_24hour=prices['price-percent-24hour']
	
	stoploss_percent=float(stoploss_percent)
	new_stoploss=round(float(price-price/100*stoploss_percent))
	new_stoploss=round(new_stoploss,2)
	hard_stoploss=new_stoploss
	stop_price=new_stoploss+stop_add
	
	last_array=nickbot.fetch_last_order(exchange,symbol)
	last_price=float(last_array['price'])
	last_type=last_array['type']
	last_units=last_array['executedQty']

	redis_key=str(symbol)+str("STOP-ACTION")
	print(last_array)
	print("LT: "+str(last_type))

	orders = exchange.fetch_open_orders(symbol,1)
	if orders:
		data=orders[0]['info']
		order_type=data['type']
		order_id=data['orderId']
		order_timestamp=data['time']/1000
		start_time=order_timestamp
		elapsed = time.time() - start_time
		elapsed=round(elapsed)
					
		print("DB ELAPSED: "+str(elapsed))
		print("DB TYPE: "+str(order_type))
		#Watch to run away buy ins!
			
		if order_type=='LIMIT' and elapsed>=300:
			exchange.cancelOrder(order_id,symbol)

	if last_type=='STOP_LOSS_LIMIT':
		last_stop_price=last_price

		redis_key=str(symbol)+str("BROADCAST-SENT")
		if redis_server.get(redis_key):
			seen=int(1)
		else:
			data="STOPLOSS HAS HIT WE SOLD: "+str(last_units)+" AT: "+str(last_price)
			nickbot.broadcast_tether('506872080',data)	
			nickbot.broadcast_tether('446619309',data)
			nickbot.broadcast_tether('693711905',data)
			
			redis_server.set(redis_key,1)
			redis_key=str(symbol)+str("STOP-ACTION")
			redis_server.set(redis_key,1)
	
		diff=nickbot.diff_percent(last_price,price)
		diff_abs=abs(diff)
		
		if price>last_price:
			direction='increased'
		else:
			direction='decreased'
			
		if diff<-decrease_per:
			orders = exchange.fetch_open_orders(symbol,1)
			if orders:
				data=orders[0]['info']
				order_type=data['type']
				order_id=data['orderId']
				order_timestamp=data['time']/1000
				start_time=order_timestamp
				elapsed = time.time() - start_time
				elapsed=round(elapsed)
					
				print("DB ELAPSED: "+str(elapsed))
				print("DB TYPE: "+str(order_type))
				#Watch to run away buy ins!
			
				if order_type=='LIMIT' and elapsed>=300:
					exchange.cancelOrder(order_id,symbol)
			else:
				data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
				data=data+"\nSINCE STOPLOSS HIT PRICE HAS DECREASED BY: "+str(diff)+" % AND IS NOW: "+str(price)+" BUYING THE CUNT BACK"+" DIRECTION: "+str(direction)
				nickbot.broadcast_tether('506872080',data)	
				nickbot.broadcast_tether('446619309',data)
				nickbot.broadcast_tether('693711905',data)				
				ret=exchange.create_order (symbol, 'limit', 'buy', last_units, price)
				time.sleep(10)
	
		elif diff>increase_per:
			orders = exchange.fetch_open_orders(symbol,1)
			if orders:
				data=orders[0]['info']
				order_type=data['type']
			else:
				data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
				data=data+"\nSINCE STOPLOSS HIT PRICE HAS INCREASED BY: "+str(diff)+" % AND IS NOW: "+str(price)+" BUYING THE CUNT BACK"+" DIRECTION: "+str(direction)
				nickbot.broadcast_tether('506872080',data)	
				nickbot.broadcast_tether('446619309',data)
				nickbot.broadcast_tether('693711905',data)
				#ret=exchange.create_order (symbol, 'limit', 'buy', last_units, price)
				time.sleep(10)
		else:
			data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
			data=data+"\nSINCE STOPLOSS HIT PRICE DIFF IS: "+str(diff)+" % AND IS NOW: "+str(price)+" DIRECTION: "+str(direction)
			redis_key=str(symbol)+str("STOP-ACTION-BC")
			if redis_server.get(redis_key):		
				seen=int(1)
			else:
				nickbot.broadcast_tether('506872080',data)	
				nickbot.broadcast_tether('446619309',data)
				nickbot.broadcast_tether('693711905',data)
				redis_key=str(symbol)+str("STOP-ACTION-BC")
				redis_server.setex(redis_key,1,1)
		stop_action=1
		return(1)
			
	diff=nickbot.diff_percent(last_price,price)
	data="<b>TRADING PAIR:</b> "+str(symbol)+"\t<b>PRICE:</b> "+str(price)+" <b>LAST PRICE:</b> "+str(last_price)+"\t"+str(diff)+" <b>PERCENT DIFFERENCE</b>\n"
	data_add="<b>1M:</b> "+str(price_1min)+" "+str(percent_1min)+str('%')+",<b>3M:</b> "+str(price_3min)+" "+str(percent_3min)+str('%')+",<b>5M:</b> "+str(price_5min)+" "+str(percent_5min)+str('%')+",<b>10M:</b> "+str(price_10min)+" "+str(percent_10min)+"%,<b>15M:</b> "+str(price_15min)+" "+str(percent_15min)+str('%')+",<b>30M:</b> "+str(price_30min)+" "+str(percent_30min)+str('%')+",<b>1H:</b> "+str(price_1hour)+" "+str(percent_1hour)+str('%')+",<b>3H:</b> "+str(price_3hour)+" "+str(percent_3hour)+str('%')+",<b>6H:</b> "+str(price_6hour)+" "+str(percent_6hour)+str('%')+",<b>12H:</b> "+str(price_12hour)+" "+str(percent_12hour)+str('%')+",<b>24H:</b> "+str(price_24hour)+" "+str(percent_24hour)+str('%')
	
	rsi=nickbot.get_rsi(symbol,'5m')

	print("Debug: PP2H; "+str(percent_2hour))
	percent_2hour=0
	nickbot.log_autotether_stats(symbol,price,percent_1min,percent_2min,percent_3min,percent_5min,percent_10min,percent_15min,percent_30min,percent_1hour,percent_3hour,percent_6hour,percent_12hour,percent_24hour,rsi)

	data=str(data)+"\n"+str(data_add)+"\n<b>RSI:</b> "+str(rsi)
	nickbot.broadcast_tether('506872080',data)
	nickbot.broadcast_tether('693711905',data)
	print("STOP ACTION: "+str(stop_action))
	if stop_action==0:
	#if stop_action==0 and float(percent_3min)<-0.3 or stop_action==0 and float(percent_1min)<-0.3:
	# or stop_action==0 and float(percent-30min)<-0.40:
		print(symbol+" Stop action is zero\n")
		orders = exchange.fetch_open_orders(symbol,1)
		if orders:
			data=orders[0]['info']
			order_type=data['type']
			order_id=data['orderId']
			print(data)
			order_timestamp=data['time']/1000
			start_time=order_timestamp
			elapsed = time.time() - start_time
			elapsed=round(elapsed)
					
			print("DB ELAPSED: "+str(elapsed))
			print("DB TYPE: "+str(order_type))
			#Watch to run away buy ins!
			
			if order_type=='LIMIT' and elapsed>=300:
				exchange.cancelOrder(order_id,symbol)
				
			if order_type=='STOP_LOSS_LIMIT':
				open_price=float(data['price'])	
				stop_price=float(data['stopPrice'])
				old_stop_price=stop_price
				stop_units=float(stop_units)
				diff=nickbot.diff_percent(new_stoploss,price)
				
				#new_stoploss=round(float(price-price/100*0.10,2))
				
				
				last_array=nickbot.fetch_last_order(exchange,symbol)
				last_price=float(last_array['price'])
				last_type=last_array['type']
				last_units=last_array['executedQty']
				
				if percent_1min<-0.20 or percent_3min<-0.35 or percent_5min<-0.5:
					new_stoploss=price-price/100*0.03
					new_stoploss=round(new_stoploss,2)
					
					if new_stoploss>=old_stop_price:
						stop_price=new_stoploss+new_stoploss/100*0.015
						stop_price=round(stop_price,2)
						print("ALERT: !!!! New Stoploss: "+str(new_stoploss)+" Is higher than Stop Price: "+str(old_stop_price)+" and is "+str(diff)+" Percent Difference\n")
						e#xchange.cancelOrder(order_id,symbol)
													
						params = {
						'stopPrice': stop_price,  # your stop price
						'type': 'STOP_LOSS_LIMIT',
						}

						#data="FLASH CRASH SELLING: LSL"+str(old_stop_price)+" NSL: "+str(new_stoploss)+" Last Buy Price: "+str(last_price)
						data="ADJUSTING STOP LOSS: "+str(old_stop_price)+" STOPLOSS TRIGGER PRICE: "+str(stop_price)+" STOPLIMIT NEW STOPLOSS: "+str(new_stoploss)+" Last Buy Price: "+str(last_price)+" CURRENT PRICE: "+str(price)
						nickbot.broadcast_tether('506872080',data)	
						nickbot.broadcast_tether('446619309',data)
						nickbot.broadcast_tether('693711905',data)
						#order = exchange.createOrder(symbol, 'limit', 'sell', stop_units, new_stoploss, params)
						print(orders)
						
				#elif percent_1min>0.10 or percent_3min>0.15:
				#
				#	new_stoploss=price-price/100*0.005
				#	new_stoploss=round(new_stoploss,2)
				#	
				#	if new_stoploss>=old_stop_price:
				#		stop_price=new_stoploss+0.001
				#			
				#		print("ALERT: !!!! New Stoploss: "+str(new_stoploss)+" Is higher than Stop Price: "+str(old_stop_price)+" and is "+str(diff)+" Percent Difference\n")
				#		exchange.cancelOrder(order_id,symbol)
				#		stop_price=new_stoploss+stop_add
				#		params = {
				#		'type': 'STOP_LOSS_LIMIT',
				#		}

				#		#data="FLASH CRASH SELLING: LSL"+str(old_stop_price)+" NSL: "+str(new_stoploss)+" Last Buy Price: "+str(last_price)
				#		data="ADJUSTING STOP LOSS: "+str(old_stop_price)+" TO: "+str(new_stoploss)+" Last Buy Price: "+str(last_price)
				#		nickbot.broadcast_tether('506872080',data)	
				#		nickbot.broadcast_tether('446619309',data)
								
				#		order = exchange.createOrder(symbol, 'limit', 'sell', stop_units, new_stoploss, params)
				#		print(orders)

				
				elif new_stoploss>=old_stop_price:
					stop_price=new_stoploss+stop_add
					print("New Stoploss: "+str(new_stoploss)+" Is higher than Stop Price: "+str(old_stop_price)+" and is "+str(diff)+" Percent Difference\n")
					#exchange.cancelOrder(order_id,symbol)
					stop_price=new_stoploss+stop_add
					params = {
					'stopPrice': stop_price,  # your stop price
					'type': 'STOP_LOSS_LIMIT',
					}
					
					#order = exchange.createOrder(symbol, 'limit', 'sell', stop_units, new_stoploss, params)

					last_array=nickbot.fetch_last_order(exchange,symbol)
					last_price=float(last_array['price'])
					last_type=last_array['type']
					last_units=last_array['executedQty']

					data="ADJUSTING STOP LOSS: "+str(old_stop_price)+" TO: "+str(new_stoploss)+" Last Buy Price: "+str(last_price)
					nickbot.broadcast_tether('506872080',data)	
					nickbot.broadcast_tether('446619309',data)
					nickbot.broadcast_tether('693711905',data)
					

					print(orders)
					
		#elif float(percent_3min)<-0.3 or float(percent_1min)<-0.3:
		else:
			#new_stoploss=round(float(price-price/100*0.10))
			stop_price=new_stoploss+stop_add
			
			params = {
			'stopPrice': stop_price,  # your stop price
			'type': 'STOP_LOSS_LIMIT',
			}

			print("Price: "+str(price)+" Stop Price: "+str(stop_price)+ "Test SL: "+str(new_stoploss))

			print(new_stoploss)
			#order = exchange.createOrder(symbol, 'limit', 'sell', stop_units, new_stoploss, params)

			redis_key=str(symbol)+str("STOP-PRICE")
			redis_server.set(redis_key,stop_price)
			print("Setting redis key: "+str(redis_key)+" To: "+str(new_stoploss))

			redis_key=str(symbol)+str("STOP-UNITS")
			redis_server.set(redis_key,stop_units)
			print("Setting redis key: "+str(redis_key)+" To: "+str(stop_units))	
	print(prices)
	#else:
		
e=0

###THINK OF A BETTER WAY TO STORE THE KEYS MAYBE WITH TIMESTAMP GIVE 5 SECS EACH WAY ON TS RANGE X-Y
#move stoploss up if 5min 1 min etc is up by X percent step up stoploss as a division of that
#symbol,stop_units,stop_add,decrease_per,increase_per,stoploss_percent
#Think about some TA to RSI
while True:
	#try:
	print("----STARTING BTC/USDT\n")
	decrease_per=float(1)
	stop_units=float(0.01)
	stop_add=float(0.5)
	increase_per=float(0.3)
	stoploss_per=float(0.75)
	main('BTC/USDT',stop_units,stop_add,decrease_per,increase_per,stoploss_per)

	print("----ENDING BTC/USDT\nn")

	print("----STARTING ETH/USDT\n")
	decrease_per=float(0.5)
	stop_units=float(0.5)
	stop_add=float(0.5)
	increase_per=float(1)
	stoploss_per=float(0.75)
	main('ETH/USDT',stop_units,stop_add,decrease_per,increase_per,stoploss_per)
	print("----ENDING ETH/USDT\nn")
	
	print("Cycle !!!!!\n")
	#except:
	#	e=1

import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def main(symbol,trading_from,trading_to,stop_units,stop_add,decrease_per,increase_per,stoploss_percent):

	stablecoin=trading_to
	increase_per=float(increase_per)
	decrease_per=float(decrease_per)
	exchange=nickbot.get_exchange()
	ticker = exchange.fetch_ticker(symbol.upper())
	pair=symbol
	bid=float(ticker['bid'])
	last=float(ticker['last'])
	ask=float(ticker['ask'])
	open=float(ticker['open'])
	close=float(ticker['close'])
	high=float(ticker['high'])
	low=float(ticker['low'])
	volume=float(ticker['quoteVolume'])
	price=close
	stop_add=float(stop_add)
	stop_action=int(0)
	price_last=int(0)
	redis_key=str(pair)+str("price-last")	
	
	if redis_server.get(redis_key):
		price_last=redis_server.get(redis_key).decode('utf-8')
		price_last=float(price_last)
	redis_server.set(redis_key,price)
	
	print("Price Now: "+str(price))
	print("Price Last: "+str(price_last))
	print("Stored Symbol: "+str(symbol))
	prices=nickbot.store_prices(symbol,price,volume)
	#print(prices)
	price_1min=prices['price-1min']
	percent_1min=prices['price-percent-1min']

	price_2min=prices['price-2min']
	percent_2min=prices['price-percent-2min']

	price_3min=prices['price-3min']
	percent_3min=prices['price-percent-3min']
		
	price_5min=prices['price-5min']
	percent_5min=prices['price-percent-5min']
	
	price_10min=prices['price-10min']
	percent_10min=prices['price-percent-10min']
	
	price_15min=prices['price-15min']
	percent_15min=prices['price-percent-15min']
		
	price_30min=prices['price-30min']
	percent_30min=prices['price-percent-30min']
	
	price_1hour=prices['price-1hour']
	percent_1hour=prices['price-percent-1hour']

	price_2hour=prices['price-2hour']
	percent_2hour=prices['price-percent-2hour']
	
	price_3hour=prices['price-3hour']
	percent_3hour=prices['price-percent-3hour']
		
	price_6hour=prices['price-6hour']
	percent_6hour=prices['price-percent-6hour']
	
	price_12hour=prices['price-12hour']
	percent_12hour=prices['price-percent-12hour']
	
	price_24hour=prices['price-24hour']
	percent_24hour=prices['price-percent-24hour']
	
	stoploss_percent=float(stoploss_percent)
	new_stoploss=round(float(price-price/100*stoploss_percent))
	new_stoploss=round(new_stoploss,2)
	hard_stoploss=new_stoploss
	stop_price=new_stoploss+stop_add
	
	last_array=nickbot.fetch_last_order(exchange,symbol)
	last_price=float(last_array['price'])
	last_type=last_array['side']
	last_units=last_array['executedQty']

	redis_key=str(symbol)+str("STOP-ACTION")
	#print(last_array)
	#print("LT: "+str(last_type))

	orders = exchange.fetch_open_orders(symbol,1)
	if orders:
		data=orders[0]['info']
		order_type=data['type']
		order_id=data['orderId']
		order_timestamp=data['time']/1000
		start_time=order_timestamp
		elapsed = time.time() - start_time
		elapsed=round(elapsed)
					
		print("DB ELAPSED: "+str(elapsed))
		print("DB TYPE: "+str(order_type))
		#Watch to run away buy ins!
			
		if order_type=='LIMIT' and elapsed>=300:
			exchange.cancelOrder(order_id,symbol)

	print("LT: "+str(last_type))
	if last_type=='SELL':
		last_stop_price=last_price

		redis_key=str(symbol)+str("BROADCAST-SENT")
		if redis_server.get(redis_key):
			seen=int(1)
		else:
			data="STOPLOSS HAS HIT WE SOLD: "+str(last_units)+" AT: "+str(last_price)
			nickbot.broadcast_tether('506872080',data)	
			nickbot.broadcast_tether('446619309',data)
			nickbot.broadcast_tether('693711905',data)
			
			redis_server.set(redis_key,1)
			redis_key=str(symbol)+str("STOP-ACTION")
			redis_server.set(redis_key,1)
	
		diff=nickbot.diff_percent(last_price,price)
		diff_abs=abs(diff)
		
		if price>last_price:
			direction='increased'
		else:
			direction='decreased'
			
		if diff<-decrease_per:
			orders = exchange.fetch_open_orders(symbol,1)
			if orders:
				data=orders[0]['info']
				order_type=data['type']
				order_id=data['orderId']
				order_timestamp=data['time']/1000
				start_time=order_timestamp
				elapsed = time.time() - start_time
				elapsed=round(elapsed)
					
				print("DB ELAPSED: "+str(elapsed))
				print("DB TYPE: "+str(order_type))
				#Watch to run away buy ins!
			
				if order_type=='LIMIT' and elapsed>=300:
					exchange.cancelOrder(order_id,symbol)
			else:
				data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
				data=data+"\nSINCE STOPLOSS HIT PRICE HAS DECREASED BY: "+str(diff)+" % AND IS NOW: "+str(price)+" BUYING THE CUNT BACK"+" DIRECTION: "+str(direction)
				nickbot.broadcast_tether_trade('506872080',data)	
				nickbot.broadcast_tether_trade('446619309',data)
				nickbot.broadcast_tether_trade('693711905',data)				
				ret=exchange.create_order (symbol, 'limit', 'buy', last_units, price)
				time.sleep(10)
	
		elif diff>increase_per:
			orders = exchange.fetch_open_orders(symbol,1)
			if orders:
				data=orders[0]['info']
				order_type=data['type']
			else:
				data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
				data=data+"\nSINCE STOPLOSS HIT PRICE HAS INCREASED BY: "+str(diff)+" % AND IS NOW: "+str(price)+" BUYING THE CUNT BACK"+" DIRECTION: "+str(direction)
				nickbot.broadcast_tether('506872080',data)	
				nickbot.broadcast_tether('446619309',data)
				nickbot.broadcast_tether('693711905',data)
				#ret=exchange.create_order (symbol, 'limit', 'buy', last_units, price)
				time.sleep(10)
		else:
			data="STOPLOSS WE SOLD: "+str(last_units)+" AT: "+str(last_price)
			data=data+"\nSINCE STOPLOSS HIT PRICE DIFF IS: "+str(diff)+" % AND IS NOW: "+str(price)+" DIRECTION: "+str(direction)
			redis_key=str(symbol)+str("STOP-ACTION-BC")
			if redis_server.get(redis_key):		
				seen=int(1)
			else:
				nickbot.broadcast_tether('506872080',data)	
				nickbot.broadcast_tether('446619309',data)
				nickbot.broadcast_tether('693711905',data)
				redis_key=str(symbol)+str("STOP-ACTION-BC")
				redis_server.setex(redis_key,1,1)
		stop_action=1
		return(1)
			
	diff=nickbot.diff_percent(last_price,price)
	data="<b>TRADING PAIR:</b> "+str(symbol)+"\t<b>PRICE:</b> "+str(price)+" <b>LAST PRICE:</b> "+str(last_price)+"\t<b>LAST TYPE:</b> "+str(last_type)+"\t"+str(diff)+" <b>PERCENT DIFFERENCE</b>\n"
	data_add="<b>1M:</b> "+str(price_1min)+" "+str(percent_1min)+str('%')+",<b>2M:</b> "+str(price_2min)+" "+str(percent_2min)+str('%')+",<b>3M:</b> "+str(price_3min)+" "+str(percent_3min)+str('%')+",<b>5M:</b> "+str(price_5min)+" "+str(percent_5min)+str('%')+",<b>10M:</b> "+str(price_10min)+" "+str(percent_10min)+"%,<b>15M:</b> "+str(price_15min)+" "+str(percent_15min)+str('%')+",<b>30M:</b> "+str(price_30min)+" "+str(percent_30min)+str('%')+",<b>1H:</b> "+str(price_1hour)+" "+str(percent_1hour)+str('%')+",<b>3H:</b> "+str(price_3hour)+" "+str(percent_3hour)+str('%')+",<b>6H:</b> "+str(price_6hour)+" "+str(percent_6hour)+str('%')+",<b>12H:</b> "+str(price_12hour)+" "+str(percent_12hour)+str('%')+",<b>24H:</b> "+str(price_24hour)+" "+str(percent_24hour)+str('%')
	
	rsi=nickbot.get_rsi(symbol,'5m')

	print("Debug: PP2H; "+str(percent_2hour))
	percent_2hour=0
	nickbot.log_autotether_stats(symbol,price,percent_1min,percent_2min,percent_3min,percent_5min,percent_10min,percent_15min,percent_30min,percent_1hour,percent_3hour,percent_6hour,percent_12hour,percent_24hour,rsi)

	data=str(data)+"\n"+str(data_add)+"\n<b>RSI:</b> "+str(rsi)
	nickbot.broadcast_tether('506872080',data)
	nickbot.broadcast_tether('693711905',data)
	print("STOP ACTION: "+str(stop_action))
	if stop_action==0:
	#if stop_action==0 and float(percent_3min)<-0.3 or stop_action==0 and float(percent_1min)<-0.3:
	# or stop_action==0 and float(percent-30min)<-0.40:
		print(symbol+" Stop action is zero\n")
		orders = exchange.fetch_open_orders(symbol,1)
		if orders:
			data=orders[0]['info']
			order_type=data['type']
			order_id=data['orderId']
			print(data)
			order_timestamp=data['time']/1000
			start_time=order_timestamp
			elapsed = time.time() - start_time
			elapsed=round(elapsed)
					
			print("DB ELAPSED: "+str(elapsed))
			print("DB TYPE: "+str(order_type))
			#Watch to run away buy ins!
			
			if order_type=='LIMIT' and elapsed>=300:
				exchange.cancelOrder(order_id,symbol)
					
		else:
			print("Cunt are we here")
			
			data="TRADING PAIR: "+str(symbol)+"\tPRICE: "+str(price)+" LAST PRICE: "+str(last_price)+"\tLAST TYPE: "+str(last_type)+"\t"+str(diff)+" PERCENT DIFFERENCE\n"
			data_add="1M: "+str(price_1min)+" "+str(percent_1min)+str('%')+"\t2M: "+str(price_2min)+" "+str(percent_2min)+str('%')+"\t3M: "+str(price_3min)+" "+str(percent_3min)+str('%')+"\t5M: "+str(price_5min)+" "+str(percent_5min)+str('%')+"\t10M: "+str(price_10min)+" "+str(percent_10min)+"%\t15M: "+str(price_15min)+" "+str(percent_15min)+str('%')+"\t30M: "+str(price_30min)+" "+str(percent_30min)+str('%')+"\t1H: "+str(price_1hour)+" "+str(percent_1hour)+str('%')+"\t3H: "+str(price_3hour)+" "+str(percent_3hour)+str('%')+"\t6H: "+str(price_6hour)+" "+str(percent_6hour)+str('%')+"\t12H: "+str(price_12hour)+" "+str(percent_12hour)+str('%')+"\t24H: "+str(price_24hour)+" "+str(percent_24hour)+str('%')
			print(str(data)+"\n"+str(data_add))
			if rsi>85:
				percent=70
				balances=exchange.fetch_balance ()
				balance=float(format(balances[trading_from]['total'],'.8f'))
				units=units=balance/100*float(percent)
				units=round(units,2)
				
				book=nickbot.fetch_order_book(exchange,pair,'bids',100)
				sell_price=float(book[0][0])
				total_amount=round(sell_price*units,2)
				message="TETHERING: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(sell_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)+" REASON: "+str(reason)
				print(message)
				
				nickbot.broadcast_tether_trade('506872080',message)	
				nickbot.broadcast_tether_trade('446619309',message)
				nickbot.broadcast_tether_trade('693711905',message)
				
				exchange=nickbot.get_exchange()
				ret=exchange.create_order (pair, 'limit', 'sell', units, sell_price)
				action='tether'
				reason='rsi over 80'
				nickbot.log_autotether_trades(symbol,price,units,percent,action,reason)
			elif rsi>80 and rsi<85:
				percent=70
				balances=exchange.fetch_balance ()
				balance=float(format(balances[trading_from]['total'],'.8f'))
				units=units=balance/100*float(percent)
				units=round(units,2)
				
				book=nickbot.fetch_order_book(exchange,pair,'bids',100)
				sell_price=float(book[0][0])
				total_amount=round(sell_price*units,2)
				message="TETHERING: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(sell_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)+" REASON: "+str(reason)
					
			elif float(percent_24hour)>=5:
				percent=50
				balances=exchange.fetch_balance ()
				balance=float(format(balances[trading_from]['total'],'.8f'))
				units=units=balance/100*float(percent)
				units=round(units,2)
				
				book=nickbot.fetch_order_book(exchange,pair,'bids',100)
				sell_price=float(book[0][0])
				total_amount=round(sell_price*units,2)
				message="TETHERING: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(sell_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)+" REASON: "+str(reason)

				print(message)
				
				nickbot.broadcast_tether_trade('506872080',message)	
				nickbot.broadcast_tether_trade('446619309',message)
				nickbot.broadcast_tether_trade('693711905',message)
				
				exchange=nickbot.get_exchange()
				ret=exchange.create_order (pair, 'limit', 'sell', units, sell_price)
				action='tether'
				reason='rsi over 80'
				nickbot.log_autotether_trades(symbol,price,units,percent,action,reason)
			
			
			elif float(percent_1min)<-0.5 or float(percent_2min)<-0.7 or float(percent_5min)<=-0.9 or float(percent_30min)<=-1:
				percent=30
				balances=exchange.fetch_balance ()
				balance=float(format(balances[trading_from]['total'],'.8f'))
				print(str(balance))
				units=units=balance/100*float(percent)
				units=round(units,2)
				
				book=nickbot.fetch_order_book(exchange,pair,'bids',100)
				sell_price=float(book[5][0])
				total_amount=round(sell_price*units,2)
				
				exchange=nickbot.get_exchange()
				ret=exchange.create_order (pair, 'limit', 'sell', units, sell_price)
				action='tether'
				reason='Percent 1m <=-0.5 or Per_2min <=-0.7 or Per 5Min<=-0.9 or Per 30Min<=-1'
				nickbot.log_autotether_trades(symbol,price,units,percent,action,reason)

				message="TETHERING: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(sell_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)+" REASON: "+str(reason)
				print(message)
				
				nickbot.broadcast_tether_trade('506872080',message)	
				nickbot.broadcast_tether_trade('446619309',message)
				nickbot.broadcast_tether_trade('693711905',message)


		#print(prices)
	#else:
		
e=0

###THINK OF A BETTER WAY TO STORE THE KEYS MAYBE WITH TIMESTAMP GIVE 5 SECS EACH WAY ON TS RANGE X-Y
#move stoploss up if 5min 1 min etc is up by X percent step up stoploss as a division of that
#symbol,stop_units,stop_add,decrease_per,increase_per,stoploss_percent
#Think about some TA to RSI
while True:
	#try:
	print("----STARTING BTC/USDT\n")
	decrease_per=float(3)
	stop_units=float(0.01)
	stop_add=float(0.5)
	increase_per=float(0.3)
	stoploss_per=float(0.75)
	main('BTC/USDT','BTC','USDT',stop_units,stop_add,decrease_per,increase_per,stoploss_per)

	print("----ENDING BTC/USDT\nn")

	print("----STARTING ETH/USDT\n")
	decrease_per=float(3)
	stop_units=float(0.5)
	stop_add=float(0.5)
	increase_per=float(1)
	stoploss_per=float(0.75)
	main('ETH/USDT','ETH','USDT',stop_units,stop_add,decrease_per,increase_per,stoploss_per)
	print("----ENDING ETH/USDT\nn")
	
	print("Cycle !!!!!\n")
	#except:
	#	e=1

import os
import sys, argparse
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import redis
import configparser
from datetime import datetime
import subprocess
import heapq
import nickbot

logging.basicConfig(filename='../logs/debug.log',level=logging.DEBUG)

r = redis.Redis(host='localhost', port=6379, db=0)

config = configparser.ConfigParser()

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402

def log_redis(redis_key,message,c):

	if c>10000:
		print(r.lpop(redis_key))
		
	now = datetime.now()
	ts = datetime.timestamp(now)
	running=datetime.fromtimestamp(ts).strftime("%Y-%m-%d %I:%M:%S")

	message=str(running)+"\t"+str(message)
	print("Writing to redis: "+str(redis_key))
	print(message)
	r.rpush(redis_key,message)

def log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id):

	key=str(symbol)+'-SYSTEM-STOPLOSS'
	if mc.get(key):
		stoploss_price=float(mc.get(key))
	else:
		stoploss_price=0
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	market_price=float(close)
	
	profit_per_unit=market_price-buy_price
	profit=float(profit_per_unit*units)
	profit=round(profit,8)
	prices = [buy_price,market_price]
	for a, b in zip(prices[::1], prices[1::1]):
		profit_percent=100 * (b - a) / a
		profit_percent=round(profit_percent,2)

	total_invest=units*buy_price
	total_now=units*market_price	

	total_now=float(total_now)
	total_now=round(total_now,8)

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = """
		INSERT INTO at_history(date,date_time,timestamp,symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low,bot_id)
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	"""
	print(sql)
	cursor.execute(sql,(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low,bot_id))
	db.close()

def fetch_wall_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def walls(symbol):
	
	symbol=symbol.upper()
	exchange=nickbot.get_exchange()
	buy_book=fetch_wall_book(exchange,symbol,'bids','500')
	sell_book=fetch_wall_book(exchange,symbol,'asks','500')

	
	buy_dic={}
	sell_dic={}
	
	for k,v in buy_book:
		buy_dic[k]=v

	for k,v in sell_book:
		sell_dic[k]=v
				
	buy_walls=heapq.nlargest(20, buy_dic.items(), key=itemgetter(1))
	sell_walls=heapq.nlargest(20, sell_dic.items(), key=itemgetter(1))
	
	message="<b>INFO:: - "+str(symbol)+"WALL INTEL:</b>\n\n"
	
	message=message+"<b>BUY WALLS ('SUPPORT')</b>\n"
	
	for k,v in sorted(buy_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"

	message=message+"\n<b>SELL WALLS ('RESISTANCE')</b>'\n"
	for k,v in sorted(sell_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"
		
	broadcast(message)

exchange=nickbot.get_exchange()

def delete_bot(symbol):
	bot_name=symbol
	r.srem("botlist", bot_name)
	r.delete(bot_name)
	redis_key="bconfig-"+bot_name
	
	blacklisted_key=redis_key+"-BLACKLIST"
	r.setex(blacklisted_key,1800,1)

	bot_id=r.hget(redis_key,'id').decode('utf-8')

	ckey=str(bot_id)+'-CPS'
	r.delete(ckey)
	r.hdel(ckey,"*")
	
	r.hdel(redis_key, "*")	
	r.delete(redis_key)
	
	key=str(symbol)+'-SYSTEM-STOPLOSS'
	mc.delete(key)
	
	config = configparser.ConfigParser()
	config_file='/home/crypto/cryptologic/pid-configs/init.ini'
	config.read(config_file)
	
	bot_section='watcher:'+str(bot_name)
	config.remove_section(bot_section)
	
	for line in config:
		print(line)
	with open(config_file, 'w') as configfile:
	
		print("debug")
		print(config)
		config.write(configfile)
		
		print("Write Config File to: "+str(config_file))
		print("Wrote: "+str(configfile))
	
	subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def broadcast(text):

	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	chatid=config['binance']['TRADES_CHANNEL']
	print(chatid)
	token = telegram_id
	timestamp=time.time()
	date_time=datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
	text="<b>"+str(date_time)+"</b>\t"+str(text)
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+text+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content
	print(html)
	
def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)
   

def fetch_last_order(exchange,symbol):
	#print("passed: "+str(symbol))
	ret=exchange.fetch_closed_orders (symbol, 1);
	#print(ret)
	if ret:
		
		data=ret[-1]['info']
		side=data['side']
		price=float(data['price'])
		print("returning: 1")
		return data
	else:
		print("returning: 0")
		data=0
		return data

def die():
	sys.exit("fuck")


def get_rsi(pair,interval):

	try:
		arr = []
		out = []
		fin = []
		url="https://api.binance.com/api/v1/klines?symbol="+pair+"&interval="+interval+"&limit=100"
		print(url)
		r=requests.get(url)
		res = (r.content.strip())
		status = r.status_code
		rsi_status=''
		trades = json.loads(res.decode('utf-8'))

		for trade in trades:
			open_price=float(trade[0])
			close_price=float(trade[4])
			high_price=float(trade[2])
			low_price=float(trade[3])
			if close_price>0:
				arr.append(close_price)
			

		np_arr = np.array(arr,dtype=float)
		output=talib.RSI(np_arr,timeperiod=14)

		for chkput in output:
			if chkput>0:
				fin.append(chkput)
		
		rsi=float(fin[-1])
		rsi=round(rsi)
		return(rsi)
	except:
		print("rsi is the problem")
		
def fetch_order_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks
		
def main(exchange,symbol,c):
	
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)
	
	redis_order_log="ORDERLOG-"+symbol
	redis_log="LOG-"+symbol
	redis_trade_log="TRADELOG-"+symbol
	redis_key="bconfig-"+symbol
	redis_rsi_log="RSILOG-"+symbol
	ret=0

	bot_id=r.hget(redis_key,'id').decode('utf-8')
	trading_on=r.hget(redis_key,"trading_on")
	trading_on=trading_on.decode('utf-8')
	rsi_symbol=r.hget(redis_key,"rsi_symbol")
	rsi_symbol=rsi_symbol.decode('utf-8')
	symbol=r.hget(redis_key,"symbol")
	symbol=symbol.decode('utf-8')
	units=r.hget(redis_key,"units")
	units=units.decode('utf-8')
	trade_from=r.hget(redis_key,"trade_from")
	trade_from=trade_from.decode('utf-8')
	trade_to=r.hget(redis_key,"trade_to")
	trade_to=trade_to.decode('utf-8')
	buy_pos=r.hget(redis_key,"buy_pos")
	buy_pos=buy_pos.decode('utf-8')	
	sell_pos=r.hget(redis_key,"sell_pos")
	sell_pos=sell_pos.decode('utf-8')
	stoploss_percent=r.hget(redis_key,"stoploss_percent")
	stoploss_percent=stoploss_percent.decode('utf-8')
	safeguard_percent=r.hget(redis_key,"safeguard_percent")
	safeguard_percent=safeguard_percent.decode('utf-8')
	use_stoploss=r.hget(redis_key,"use_stoploss")
	use_stoploss=use_stoploss.decode('utf-8')
	candle_size=r.hget(redis_key,"candle_size")
	candle_size=candle_size.decode('utf-8')
	rsi_buy=r.hget(redis_key,"rsi_buy")
	rsi_buy=rsi_buy.decode('utf-8')
	rsi_sell=r.hget(redis_key,"rsi_sell")
	rsi_sell=rsi_sell.decode('utf-8')
	live=r.hget(redis_key,"live")
	live=live.decode('utf-8')
	enable_safeguard=r.hget(redis_key,"enable_safeguard")
	enable_safeguard=enable_safeguard.decode('utf-8')
	enable_buybacks=r.hget(redis_key,"enable_buybacks")
	if enable_buybacks:
		enable_buybacks=enable_buybacks.decode('utf-8')
	rsi_sell=float(rsi_sell)
	rsi_buy=float(rsi_buy)
	stoploss_percent=float(stoploss_percent)
	safeguard_percent=float(safeguard_percent)
	use_stoploss=str(use_stoploss)
	if use_stoploss=='1':
		use_stoploss=str('yes')
		
	units=float(units)
	sell_pos=int(sell_pos)
	buy_pos=int(buy_pos)
	
	message="Exchange: "+trading_on+"\tExchange: "+trading_on+"\tTrade Pair: "+str(symbol)+"\tUnits: "+str(units)+"\tBuy Book Scrape Position: "+str(buy_pos)+"\tSell Book Scrape Position: "+str(sell_pos)+"\tRSI Buy: "+str(rsi_buy)+"\tRSI Sell: "+str(rsi_sell)+"\tStoploss Percent: "+str(stoploss_percent)+"\tSafeguard Percent: "+str(safeguard_percent)+"\tEnable Safeguard: "+str(enable_safeguard)+"\tCandle Size: "+candle_size+"\tUse Stoploss: "+str(use_stoploss)+"\tLive Trading Enabled: "+live+" BOID: "+str(bot_id)

	if c==0:
		log_redis(redis_log,message,c)
		print(message)

	key=str(symbol)+'-ORIGINAL-SL'	
	r.setex(key,3600,stoploss_percent)

	ignore_rsi=0
	sleep_for_after_stoploss_executed=600
	
	#If the manual bot is doing sell off then dont interfere
	key=str(symbol)+'-PAUSED'	
	if(mc.get(key)):
		#time.sleep(30)
		return(1)
	
	key=str(symbol)+'-SL'	
	if(mc.get(key)):
		ignore_rsi=1
		print("Got Stoploss key\n")
		mc.delete(key)
	
	original_stoploss_price=0
	key=str(symbol)+'-ORIGINAL-STOPLOSS-PRICE'	
	if(mc.get(key)):
		original_stoploss_price=float(mc.get(key))
		print(original_stoploss_price)
		
	exchange_cut=0.007500;
	
	tkey="seen"+str(symbol)
	orders = exchange.fetch_open_orders(symbol,1)
	
	open_order=len(orders)
	
	ticker = exchange.fetch_ticker(symbol.upper())
	bid=float(ticker['bid'])
	last=float(ticker['last'])
	ask=float(ticker['ask'])
	open=float(ticker['open'])
	close=float(ticker['close'])
	high=float(ticker['high'])
	low=float(ticker['low'])
	
	key=str(symbol)+'-LAST-PRICE'	
	#mc.set(key,close,86400)
	r.setex(key,3600,close)
	print("ATDB: "+str(key)+"\t"+str(close))
	
	
	lo_key="last_order-"+str(symbol)
	if mc.get(lo_key):
		last_array=mc.get(lo_key)
		last_price=float(last_array['price'])
		last_type=last_array['side']
		buy_price=last_price
	else:
		#Cache last order in ram for 60 seconds to speed up api calls
		print("Db: lT: "+str(symbol))
		last_array=fetch_last_order(exchange,symbol)
		if last_array!=0:
			last_price=float(last_array['price'])
			last_type=last_array['side']
			buy_price=last_price			
			mc.set(lo_key,last_array,60)
		else:
			last_type='NULL'
			
	if open_order:
		for order in orders:
			order_symbol=order['info']['symbol']
			if order_symbol==rsi_symbol:
				open_type=order['info']['side']
				open_price=order['price']
				open_filled=order['filled']
				open_remaining=order['remaining']
				open_fee=order['fee']
				order_id=order['info']['orderId']				
				order_timestamp=order['timestamp']/1000
				start_time=order_timestamp
				elapsed = time.time() - start_time
				elapsed=round(elapsed)
								
				message="<b>ALERT:: - "+str(symbol)+" OPEN ORDER\tTYPE:</b> " +str(open_type)+"\n<b>OPEN FOR: </b> "+str(elapsed)+" Seconds\n"+"<b>PRICE:</b> "+str(open_price)+ "\n<b>FILLED:</b> "+str(open_filled)+"/"+str(open_remaining)+"\n<b>ORDER ID:</b> "+str(order_id)+"\t<b>TICKER\tLAST:</b> "+str(last)+" <b>BID:</b> "+str(bid)+" <b>ASK:</b> "+str(ask)				
				if open_type=='BUY' and float(elapsed)>300:
					exchange.cancelOrder(order_id,symbol)
					delete_bot(symbol)		
					message=message+"\n\n<b>CANCELLING ORDER TO MUCH TIME ELAPSED</b>\n"
					broadcast(message)
				
				oo_key=str(symbol)+'-OOssTMPS'	
				if not (mc.get(oo_key)):
					mc.set(oo_key,1,1800)			
					broadcast(message)
					log_redis(redis_log,message,c)
					print(message)
		return("open")

	print("LT: "+str(last_type))
	
	print("USL: "+str(use_stoploss))
	if use_stoploss=="yes" or use_stoploss==1:
			
		if last_type=='BUY':
					
			stoploss=last_price/100*stoploss_percent
			stoploss_price=last_price-stoploss

			print("Debug SL: "+str(stoploss_percent))
			print("Debug SLP: "+str(stoploss_price))
			print("Debug LP: "+str(last_price))
			print("Debug OSL: "+str(original_stoploss_price))
						
			### ADD SMART STOPLOSS CODE
			key=str(symbol)+'-SYSTEM-STOPLOSS'
			if mc.get(key):
				stoploss_price=float(mc.get(key))
				sell_price=stoploss_price
			else:
				book=fetch_order_book(exchange,symbol,'bids',1)
				sell_price=float(book[0][0])

			#IF WE ARE USING A STOPLOSS TRIGGER SET THE THiNG TO TRIGGER STOPLOSS TO THE TRIGGER AND SELL PRICE TO THE STOPLOSS PRICE
			#if checkpoint_trigger>0:
			#sell_price=stoploss_price
			#stoploss_price=checkpoint_trigger
				

			message="Last buy price: "+str(last_price)+"\tStoploss price: "+str(stoploss_price)+"\tmarket price: "+str(last)
			log_redis(redis_log,message,c)
			log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)
			print(message)

			if last <= stoploss_price or last <= original_stoploss_price:

				book=fetch_order_book(exchange,symbol,'bids',1)
				sell_price=float(book[0][0])

				mc.delete(key)
				print("creating stoploss order: "+str(sell_price))
				message="<b>ALERT:: - "+str(symbol)+" STOPLOSS HIT</b>, <b>SELLING:</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(sell_price)+" <b>LAST BUY @:</b>"+str(last_price)
				broadcast(message)
				print(message)
				log_redis(redis_trade_log,message,c)
				log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)
				if live=="yes":
				
					ret=exchange.create_order (symbol, 'limit', 'sell', units, sell_price)
					order_id=ret['info']['orderId']
					m=str(bot_id)+"\t"+str(order_id)+"\tSELL\t"+str(symbol)+"\t"+str(rsi_symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(sell_price)+"\t"+str(units)
					log_redis(redis_order_log,m,c)
					logging.debug(m)
					nickbot.log_order(exchange,bot_id,order_id,'SELL',symbol,rsi_symbol,trade_from,trade_to,sell_price,units)
					broadcast(message)

					message="Killing Bot"
					log_redis(redis_trade_log,message,c)
					if enable_buybacks=='no':
						delete_bot(symbol)			
						print("killing bot/deleting it")	
						return("kill")
						key=str(symbol)+'-SL'	
						mc.set(key,1,86400)		
						
						print("MARKET PRICE: "+str(last))
						profit_per_unit=float(last)-float(last_price)
						profit_total=float(profit_per_unit*units)
						profit_total=round(profit_total,8)
						prices = [last_price,last]
						for a, b in zip(prices[::1], prices[1::1]):
							percent=100 * (b - a) / a
							percent=round(percent,2)
						if percent<0:
							redis_key="bconfig-"+bot_name
							blacklisted_key=redis_key+"-BLACKLIST"
							r.setex(blacklisted_key,3600,1)

	else:
		
		rsikey="rsi"+str(symbol)
		rsi=get_rsi(rsi_symbol,candle_size)
		print("RSI")
		print(rsi)
		rsi=float(rsi)
	
		lo_key="last_order-"+str(symbol)
		mc.delete(lo_key)
		if mc.get(lo_key):
			last_array=mc.get(lo_key)
			last_price=float(last_array['price'])
			last_type=last_array['side']
		else:
			#Cache last order in ram for 60 seconds to speed up api calls
			print("Db: lT: "+str(symbol))
			last_array=fetch_last_order(exchange,symbol)
			last_price=float(last_array['price'])
			last_type=last_array['side']
			mc.set(lo_key,last_array,60)
		
		print(last_array)
		if last_price==0.00:
			#Was a market buy so we didn't pass a buy price work it out by cummulativeQuoteQty/aka fee / units
			market_fee=float(last_array['cummulativeQuoteQty'])
			market_units=float(last_array['origQty'])
			last_price=market_fee/market_units
			print("Debug LA: ")
			print(last_price)
			print(last_array)
	
		if last_type=='BUY':
			trade_action='selling'
		else:
			trade_action='buying'

		#Added forcebuy usefull if u wanna force a buy on rsi without instant buy @ market
		fbkey=symbol+"-FORCE-BUY"
		if mc.get(fbkey):
			trade_action='buying'
			mc.delete(fbkey)

		fskey=symbol+"-FORCE-SELL"
		if mc.get(fskey):
			trade_action='selling'
			mc.delete(fskey)

		message="No open orders Currently RSI: "+str(rsi)	
		log_redis(redis_log,message,c)
		print(message)

		if ticker:
			message=str(symbol)+"\t"+str(bid)+"\t"+str(ask)+"\t"+str(last)+"\t"+str(high)+"\t"+str(low)+"\t"+str(rsi)
			log_redis(redis_rsi_log,message,c)
	
		got_key=int(0)
		key=str(symbol)+'-SYSTEM-BUYBACK'
		if mc.get(key):
			got_key=0

		if trade_action=="buying" and rsi<=rsi_buy or trade_action=="buying" and ignore_rsi==1 or trade_action=="buying" and got_key==1:
			
			if use_stoploss=="yes":
				stoploss=last_price/100*stoploss_percent
				stoploss_price=last_price-stoploss
		
				print("Debug: "+str(stoploss_percent))
				print("Last Price: "+str(last_price))
			
				### ADD SMART STOPLOSS CODE
				key=str(symbol)+'-SYSTEM-STOPLOSS'
				if mc.get(key):
					stoploss_price=float(mc.get(key))	
						
				print("last buy price: "+str(last_price))
				print("stoploss price: "+str(stoploss_price))
				print("market price: "+str(last))
					
				message="Last buy price: "+str(last_price)+"\tStoploss price: "+str(stoploss_price)+"\tmarket price: "+str(last)
				log_redis(redis_log,message,c)
				print(message)

				if last <= stoploss_price or last <= original_stoploss_price:		
					mc.delete(key)
					book=fetch_order_book(exchange,symbol,'bids',1)
					sell_price=float(book[0][0])
					print("creating stoploss order: "+str(sell_price))
					message="<b>ALERT:: - "+str(symbol)+" STOPLOSS HIT</b> <b>SELLING:</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(sell_price)+" <b>LAST BUY @:</b>"+str(last_price)
					broadcast(message)
					log_redis(redis_trade_log,message,c)
					
					log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)
					if live=="yes":
						ret=exchange.create_order (symbol, 'limit', 'sell', units, sell_price)
						order_id=int(ret['info']['orderId'])
						m=str(bot_id)+"\t"+str(order_id)+"\tSELL\t"+str(symbol)+"\t"+str(rsi_symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(sell_price)+"\t"+str(units)
						log_redis(redis_order_log,m,c)
						logging.debug(m)
						nickbot.log_order(exchange,bot_id,order_id,'SELL',symbol,rsi_symbol,trade_from,trade_to,sell_price,units)
					
					if enable_buybacks=='no':
						message="killing script no buyback here :"+str(sleep_for_after_stoploss_executed)+ "seconds now giving market time to adjust our dough is tethered"
						delete_bot(symbol)
						broadcast(message)	
						return("kill")
						
						key=str(symbol)+'-KILL'	
						mc.set(key,1,86400)			
						
						key=str(symbol)+'-SL'	
						mc.set(key,1,86400)	
						
			if enable_safeguard=='yes':
				safeguard=last_price/100*safeguard_percent
				price=last_price-safeguard
			else:
				book=fetch_order_book(exchange,symbol,'bids',1)
				price=float(book[buy_pos][0])
				
			exchange_cut=price/100*0.007500
			price=price-exchange_cut
			print("Making buyorder for "+str(units)+" price: "+str(price)+"\n")	
	
			message="<b>ALERT:: - "+str(symbol)+" BUYING</b> "+str(units)+"UNITS\t<b>BUY @:</b> "+str(price)+"\t<b>LAST SELL @:</b> "+str(last_price)
			log_redis(redis_trade_log,message,c)
			log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)
			broadcast(message)
			print(ret)
			message="Live Ticker:\nBid: "+str(bid)+" Ask: "+str(ask)+ " Last: "+str(last)+ "\nHigh: "+str(high)+" Low: "+str(low)+"\nOpen: "+str(open)+" Close: "+str(close)+"\n"
			if live=="yes":
				ret=exchange.create_order (symbol, 'limit', 'buy', units, price)
				order_id=int(ret['info']['orderId'])
				m=str(bot_id)+"\t"+str(order_id)+"\tBUY\t"+str(symbol)+"\t"+str(rsi_symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(price)+"\t"+str(units)
				log_redis(redis_order_log,m,c)
				logging.debug(m)
				#log_order(bot_id,order_id,'BUY',symbol,rsi_symbol,trade_from,trade_to,price,units)
				print(ret)

			log_redis(redis_trade_log,message,c)
			print(message)
		elif trade_action=="selling" and rsi>=rsi_sell:
			book=fetch_order_book(exchange,symbol,'asks',1)
			price=float(book[sell_pos][0])
		
			if price < last_price and enable_safeguard=='yes':
				message=str(price)+" is under: "+str(last_price)
				log_redis(redis_trade_log,message,c)
				safeguard=last_price/100*safeguard_percent
				price=last_price+safeguard
				message="Using safeguard price is now: "+str(price)
				log_redis(redis_trade_log,message,c)
				print(message)
				
			exchange_cut=price/100*0.007500
			price=price+exchange_cut
			
			print("Making sell order for "+str(units)+" price: "+str(price)+"\n")

			message="<b>ALERT:: - "+str(symbol)+" SELLING</b> "+str(units)+"UNITS\t<b>SELL @:</b> "+str(price)+"\t<b>LAST BUY:</b> "+str(last_price)
			broadcast(message)
			log_redis(redis_trade_log,message,c)
			log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)

			if live=="yes":
				ret=exchange.create_order (symbol, 'limit', 'sell', units, price)
				order_id=int(ret['info']['orderId'])
				m=str(bot_id)+"\t"+str(order_id)+"\tSELL\t"+str(symbol)+"\t"+str(rsi_symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(price)+"\t"+str(units)
				log_redis(redis_order_log,m,c)
				logging.debug(m)
				nickbot.log_order(exchange,bot_id,order_id,'SELL',symbol,rsi_symbol,trade_from,trade_to,price,units)
				print(ret)
			message="\nLive Ticker:\nBid: "+str(bid)+" Ask: "+str(ask)+ " Last: "+str(last)+ "\nHigh:"+str(high)+" Low: "+str(low)+"\nOpen: "+str(open)+" Close: "+str(close)+"\n"
			
			log_redis(redis_trade_log,message,c)
			log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id)
			
			if enable_buybacks=='no':
				message="killing script no buyback here success sell without stoploss hitting"
				delete_bot(symbol)
				broadcast(message)	
				return("kill")
		
			message="<b>ALERT:: - "+str(symbol)+"</b>\nThe market Conditions are not right for a buy or sell <b>RSI is:</b> "+str(rsi)+" Our next action is -> "+str(trade_action)
			print(message)
			tm_key=str(symbol)+'-TMPS'	
			if not (mc.get(tm_key)):
				mc.set(tm_key,1,600)			
				broadcast(message)
				#walls(symbol)
				log_redis(redis_log,message,c)

		return(1)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

parser = argparse.ArgumentParser()

parser.add_argument('--trading_pair', help='Trading pair i.e BTC/USDT')
args = parser.parse_args()

symbol=str(args.trading_pair)
print(symbol)

if r.sismember('botlist',symbol)==0:
	delete_bot(symbol)			
	sys.exit("bot not in list")
	print("bot not in list")
c=0

message="<b>ALERT:: SPAWNED A NEW BOT FOR: "+str(symbol)+"</b>"
print(message)
#broadcast(message)

while True:
	ret="meh"
	
	#try:
	#print("tying")
	ret=main(exchange,symbol,c)
	#except:
	#print("threw error sleeping for 3 seconds")
	#time.sleep(5)
	
	if ret=="kill":
		print("killing")
		delete_bot(symbol)			
		sys.exit("die")
	c+=1
	time.sleep(0.5)import os
from collections import OrderedDict
import requests
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import talib
import numpy as np
import ccxt
import redis
import datetime
import configparser
import subprocess
import time
import shlex
import argparse
import heapq
config = configparser.ConfigParser()
config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database='cmc'
telegram_id=config['binance']['TEEGRAM_ID_EMBED']

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')
	
r = redis.Redis(host='localhost', port=6379, db=0)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

def get_exchange():
	
	#Read in our apikeys and accounts
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	conf=config['binance']
	
	binance_api_key=config['binance']['API_KEY']
	binance_api_secret=config['binance']['API_SECRET']
	
	exchange = ccxt.binance({
    'apiKey': binance_api_key,
    'secret': binance_api_secret,
    'enableRateLimit': True,
    'rateLimit': 3600,
    'verbose': False,  # switch it to Fal_se if you don't want the HTTP log
	})
	return(exchange)

def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)

exchange=get_exchange()
tickers=fetch_prices(exchange,'BTC/USDT')
btc_price=float(tickers['close'])

tickers=fetch_prices(exchange,'ETH/USDT')
eth_price=float(tickers['close'])

print(btc_price)
print(eth_price)import redis

def gotbot(symbol):
	
	redis_server = redis.Redis(host='localhost', port=6379, db=0)
	botlist=redis_server.smembers("botlist")
	print(len(botlist))	
	seen=0
	for bot in botlist:
		bot=bot.decode('utf-8')
		if bot==symbol:
			seen=1
	print("Seen: "+str(seen))
	return(seen)

coin='PHB/BTC'
if gotbot(coin)==1:
	print("Got it")
#print gotbot(coin)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

exchange=nickbot.get_exchange()	

def gotbot(symbol):
	
	redis_server = redis.Redis(host='localhost', port=6379, db=0)
	botlist=redis_server.smembers("botlist")
	
	seen=0
	for bot in botlist:
		bot=bot.decode('utf-8')
		if bot==symbol:
			seen=1
	return(seen)
	
def broadcast_moon(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['MOON_TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content	

def broadcast(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content
	print(html)
	
def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)
   

def fetch_last_order(exchange,symbol):
	ret=exchange.fetch_closed_orders (symbol, 1,"");
	if ret:
		data=ret[-1]['info']
		side=data['side']
		price=data['price']
		#print("returning: 1")
	else:
		#print("returning: 0")
		data=0
	return data

def die():
	sys.exit("fuck")

def get_price(pair,start_ts,end_ts):

	p=0
	#try:
	start_ts=start_ts+"000"
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&startTime="+str(start_ts)+"&interval=1m&limit=100"
	print(url)
	r=requests.get(url)
	res = (r.content.strip())
	print("R: "+str(res))
	status = r.status_code
	print(status)
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))
	data=trades[0]
	price=float(data[4])
	return(price)
	#except:
	#	p=1

def diff_percent(low,high):
	prices = [low,high]
	for a, b in zip(prices[::1], prices[1::1]):
		pdiff=100 * (b - a) / a
	pdiff=round(pdiff,2)

	return(pdiff)

def get_sentiment(symbol):
	
	exchange=nickbot.get_exchange()	
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	

	ts_5mins = ts_now - datetime.timedelta(seconds=300)
	ts_5mins_ts=int(time.mktime(ts_5mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_5mins_ts).strftime("%Y-%m-%d %H:%M:%S")

	buys=0
	sells=0
	total=0
	slast_price=0
	price_up=0
	price_down=0

	trades=exchange.fetchTrades (symbol)
	for trade in trades:
		side=trade['side']
		sprice=float(trade['info']['p'])

		if side=='buy':
			buys+=1
		else:
			sells+=1

		if slast_price>0 and sprice>slast_price:
			price_up+=1
	
		if slast_price>0 and sprice<slast_price:
			price_down+=1		

		slast_price=sprice
		total+=1	
	
	trade_total=price_up+price_down
	price_up_ratio=100-abs(diff_percent(trade_total,price_up))
	price_down_ratio=100-abs(diff_percent(trade_total,price_down))
	buy_ratio=100-abs(diff_percent(total,buys))
	sell_ratio=100-abs(diff_percent(total,sells))

	sell_ratio=round(sell_ratio,2)
	buy_ratio=round(buy_ratio,2)

	redis_server.set('SENT-BUYS',str(buy_ratio))
	redis_server.set('SENT-SELLS',str(sell_ratio))
	redis_server.set('SENT-PRICE-UP-RATIO',str(price_up_ratio))

	dat="\n<b>:::SENTIMENT DATA:::\nBUYS:</b> "+str(buys)+' ('+str(buy_ratio)+'%)\n<b>SELLS:</b> '+str(sells)+' ('+str(sell_ratio)+'%)'+"\n"+'<b>PRICE UP RATIO:</b> '+str(price_up)+' ('+str(price_up_ratio)+'%)'
	return(dat)

def mojo(pair,price_now):

	mc = memcache.Client(['127.0.0.1:11211'], debug=0)

	blank=1
	
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	key=str(pair)+str("pkey-30secs")
	if(mc.get(key)):
		mc.delete(key)

	ts_30secs = ts_now - datetime.timedelta(seconds=30)
	ts_30secs_ts=int(time.mktime(ts_30secs.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_30secs_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_30_secs_ago=get_price(pair,str(ts_30secs_ts),str(ts_now_ts))
	if price_30_secs_ago:
		price_30_secs_ago=float(price_30_secs_ago)
		print("P30SA")
		print(price_30_secs_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_30_secs_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 30 Seconds Ago "+str(tsd)+" : "+str(price_30_secs_ago)+" Diff %: "+str(price_diff))

	key=str(pair)+str("pkey-1mins")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_1mins = ts_now - datetime.timedelta(seconds=60)
	ts_1mins_ts=int(time.mktime(ts_1mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_1mins_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_1_mins_ago=get_price(pair,str(ts_1mins_ts),str(ts_now_ts))
	if price_1_mins_ago:
		price_1_mins_ago=float(price_1_mins_ago)
		print("P1MA")
		print(price_1_mins_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_1_mins_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 1 Mins Ago "+str(tsd)+" : "+str(price_1_mins_ago)+" Diff %: "+str(price_diff))

	key=str(pair)+str("pkey-3mins")
	if(mc.get(key)):
		mc.delete(key)

	ts_3mins = ts_now - datetime.timedelta(seconds=180)
	ts_3mins_ts=int(time.mktime(ts_3mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_3mins_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_3_mins_ago=get_price(pair,str(ts_3mins_ts),str(ts_now_ts))
	if price_3_mins_ago:
		price_3_mins_ago=float(price_3_mins_ago)
		print("P3MA")
		print(price_3_mins_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_3_mins_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)

	key=str(pair)+str("pkey-5mins")
	if(mc.get(key)):
		mc.delete(key)
		print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 3 Mins Ago "+str(tsd)+" : "+str(price_3_mins_ago)+" Diff %: "+str(price_diff))

	ts_5mins = ts_now - datetime.timedelta(seconds=300)
	ts_5mins_ts=int(time.mktime(ts_5mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_5mins_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_5_mins_ago=get_price(pair,str(ts_5mins_ts),str(ts_now_ts))
	if price_5_mins_ago:
		price_5_mins_ago=float(price_5_mins_ago)
		print("P5MA")
		print(price_5_mins_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_5_mins_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 5 Mins Ago "+str(tsd)+" : "+str(price_5_mins_ago)+" Diff %: "+str(price_diff))

	key=str(pair)+str("pkey-15mins")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_15mins = ts_now - datetime.timedelta(seconds=900)
	ts_15mins_ts=int(time.mktime(ts_15mins.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_15mins_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_15_mins_ago=get_price(pair,str(ts_15mins_ts),str(ts_now_ts))
	if price_15_mins_ago:
		price_15_mins_ago=float(price_15_mins_ago)
		print("P15MA")
		print(price_15_mins_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_15_mins_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 1 Hour Ago "+str(tsd)+" : "+str(price_15_mins_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-1hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_1hour = ts_now - datetime.timedelta(seconds=3600)
	ts_1hour_ts=int(time.mktime(ts_1hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_1hour_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	price_1_hours_ago=get_price(pair,str(ts_1hour_ts),str(ts_now_ts))
	if price_1_hours_ago:
		price_1_hours_ago=float(price_1_hours_ago)
		print("P1HA")
		print(price_1_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_1_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 1 Hour Ago "+str(tsd)+" : "+str(price_1_hours_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-3hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_3hour = ts_now - datetime.timedelta(seconds=10800)
	ts_3hour_ts=int(time.mktime(ts_3hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_3hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_3_hours_ago=get_price(pair,str(ts_3hour_ts),str(ts_now_ts))
	if price_3_hours_ago:
		price_3_hours_ago=float(price_3_hours_ago)
		print("P3HA")
		print(price_3_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_3_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 3 Hour Ago: "+str(tsd)+" : "+str(price_3_hours_ago)+" Diff %: "+str(price_diff))
			threee_hour_up_perc=price_diff
	key=str(pair)+str("pkey-6hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_6hour = ts_now - datetime.timedelta(seconds=21600)
	ts_6hour_ts=int(time.mktime(ts_6hour.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_6hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_6_hours_ago=get_price(pair,str(ts_6hour_ts),str(ts_now_ts))
	if price_6_hours_ago:
		price_6_hours_ago=float(price_6_hours_ago)
		print("P6HA")
		print(price_6_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_6_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" "+str(price_now)+" 6 Hour Ago: "+str(tsd)+" : "+str(price_6_hours_ago)+" Diff %: "+str(price_diff))
	
	key=str(pair)+str("pkey-12hour")
	if(mc.get(key)):
		mc.delete(key)
	
	ts_12hour = ts_now - datetime.timedelta(seconds=43200)
	ts_12hour_ts=int(time.mktime(ts_12hour.timetuple()))

	tsd=datetime.datetime.fromtimestamp(ts_12hour_ts).strftime("%Y-%m-%d %H:%M:%S")
		
	price_12_hours_ago=get_price(pair,str(ts_12hour_ts),str(ts_now_ts))
	if price_12_hours_ago:
		price_12_hours_ago=float(price_12_hours_ago)
		
		print("P12HA")
		print(price_12_hours_ago)
		price_now=float(price_now)
		price_diff=diff_percent(price_12_hours_ago,price_now)
		if price_diff:		
			mc.set(key,price_diff,86400)
			print("ALERTS::: Price Now: "+str(ts_now_human)+" "+str(price_now)+" 12 Hour Ago: "+str(tsd)+" : "+str(price_12_hours_ago)+" Diff %: "+str(price_diff))
	#except:
	#	print("")
	#sys.exit("Die")

mojo('WTCBTC','0.0002012')
sys.exit("c")
def get_rsi(pair,interval):

	arr = []
	out = []
	fin = []
	url="https://api.binance.com/api/v1/klines?symbol="+pair+"&interval="+interval+"&limit=500"
	#print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	#print("Status: "+str(status))
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))

	lp=0
	for trade in trades:
		open_price=float(trade[0])
		close_price=float(trade[4])
		high_price=float(trade[2])
		low_price=float(trade[3])
		if close_price>0 and close_price!=lp:
			arr.append(close_price)	
		lp=close_price

	np_arr = np.array(arr,dtype=float)
	output=talib.RSI(np_arr,timeperiod=15)

	for chkput in output:
		if chkput>0:
			fin.append(chkput)
		
	rsi=float(fin[-1])
	rsi=round(rsi)
	return(rsi)

def fetch_order_book(exchange,symbol,type,qlimit):
	limit = 1000
	ret=exchange.fetch_order_book(symbol, limit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def main():
	
	from datetime import date
	tickers=exchange.fetchTickers()
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)
	for coin in tickers:
		
		first=0
		skip=1
		broadcast_message=0
		price_jump=0
		coin=str(coin)
		rsi=100
		errors=0
		btc_price=float(tickers['BTC/USDT']['close'])
		btc_percent=float(tickers['BTC/USDT']['percentage'])
		last_price=0
		symbol=tickers[coin]['info']['symbol']
		print("SDBS: "+str(coin))
		csymbol=coin
		csymbol=csymbol.replace("/","_",1)
		det=int(0)
		today = str(date.today())
		data=str()
		row=tickers[coin]
		symbol=row['info']['symbol']
		close=row['close']
		percent=row['percentage']
		low=row['low']
		high=row['high']
		qv=row['quoteVolume']
		price=close
		dprint=1
		pair=symbol
		our_percent=0
		rsi_3m=0
		rsi_5m=0
		price_jump=0
		alerts=""
		
		#if 'USD' in symbol:
		#	min_vol=1000000
		#	skip=0
		#elif 'PAX' in symbol:
		#	min_vol=1000000
		#	skip=0
		#elif 'BTC' in symbol:
		#	min_vol=500
		#	skip=0
		#elif 'BNB' in symbol:
		#	min_vol=50000
		#	skip=0
		#elif 'ETH' in symbol:
		#	min_vol=1000	
		#	skip=0
		vol24=float(nickbot.v24_usd_alerts_cached(exchange,coin,qv))
		vol24=round(vol24,2)

		if vol24>500000:
			skip=0
		else:
			skip=1
			print(symbol+" VOL TO LOW: "+str(vol24))
		#	timetrades=float(nickbot.trade_time(exchange,coin))
		#	if timetrades>60:
		#		print(str(symbol)+"TRADES TOOK TO LONG")
		#		skip=1
		#else:
		#	print(symbol+" VOL TO LOW: "+str(vol24))
		#	skip=1
		#skip=0
		if 'BCHSV' in symbol:
			continue
			
		if low==0 or high==0:
			print("Skipping LH")
			continue
		print(symbol)
		
		redis_key="ASLASTPRICE-"+symbol
		if redis_server.get(redis_key):
			last_price=float(redis_server.get(redis_key))
			first=0
			darr = [last_price,price]
			for a, b in zip(darr[::1], darr[1::1]):
				price_jump=100 * (b - a) / a
				price_jump=round(price_jump,2)
		else:
			first=1
		
		prices = [low,high]
		for a, b in zip(prices[::1], prices[1::1]):
			pdiff=100 * (b - a) / a
			
		pdiff=round(pdiff,2)
				
		spread=pdiff
			
		nickbot.log_binance(symbol,price,percent,spread,low,high,qv,btc_price,btc_percent)

		print("DBPercent: "+str(percent)+" Price jump: "+str(price_jump)+" Price: "+str(price)+" Last Price: "+str(last_price)+" BTC PRICE: "+str(btc_price)+" BTC PER: "+str(btc_percent))
			
		if skip!=1:
			
			pair=symbol
			
			#if percent>1 and last_price>0 and price_jump>0.01 and price>last_price or percent>1 and first==1:
			if percent>1 and last_price>0 and price>last_price or percent>1 and first==1:

				print("ALERTS DEBUG::: LP: "+str(last_price)+" P: "+str(price)+" D: "+str(price_jump))
	
				key = str(date.today())+str('ALERTSDBN2')+str(csymbol)
				if mc.get(key):
					#print("Seen Ignoring it")
					dprint=2
				else:	
					det=int(1)
					mc.set(key,1,60)
					
					try:
						rsi_3m=get_rsi(symbol,'3m')
						rsi_5m=get_rsi(symbol,'5m')
						rsi_stats="<b>RSI 3M:</b> "+str(rsi_3m)+" <b>RSI 5M:</b> "+str(rsi_5m)
					except:
						print("Rsi is the issue")
						errors=1					
					
					#try:
					mojo(symbol,close)
					#except:
					#	#print("Error getting Trades")
					#	errors=1
									
					#print("DBERRORS: "+str(errors))		
					key=str(pair)+str("pkey-1hour")
					if mc.get(key):
						one_hours=mc.get(key)
					else:
						one_hours=0
			
					key=str(pair)+str("pkey-3hour")
					if mc.get(key):
						three_hours=mc.get(key)
					else:
						three_hours=0
							
					key=str(pair)+str("pkey-6hour")
					if mc.get(key):
						six_hours=mc.get(key)
					else:
						six_hours=0
						
					key=str(pair)+str("pkey-12hour")
					if mc.get(key):
						twelve_hours=mc.get(key)
					else:
						twelve_hours=0
				
					key=str(pair)+str("pkey-15mins")
					if mc.get(key):
						fifteen_mins=mc.get(key)
					else:
						fifteen_mins=0

					key=str(pair)+str("pkey-30secs")
					if mc.get(key):
						thirty_secs=mc.get(key)
					else:
						thirty_secs=0

					key=str(pair)+str("pkey-1mins")
					if mc.get(key):
						one_mins=mc.get(key)
					else:
						one_mins=0
						
					key=str(pair)+str("pkey-3mins")
					if mc.get(key):
						three_mins=mc.get(key)
					else:
						three_mins=0
						
					key=str(pair)+str("pkey-5mins")
					if mc.get(key):
						five_mins=mc.get(key)
					else:
						five_mins=0
					
					#Lets log the price every 60 seconds to look for jumps
					redis_key="ASLASTPRICE-"+symbol
					if redis_server.get(redis_key):
						last_price=redis_server.get(redis_key)
						
					if errors==0 and one_hours>0.05 and float(price)>float(last_price) or errors==0 and one_hours>0.05 and first==1:
						
						redis_key="ASLASTPRICE-"+symbol
						redis_server.setex(redis_key,3600,price)
											
						link='https://www.binance.com/en/trade/pro/'+csymbol
						alert_type=' PRICE ALERT: '+str(twelve_hours)+'%:::'					
							
						data_add="<b>30S:</b> "+str(thirty_secs)+str('%')+", <b>1M:</b> "+str(one_mins)+str('%')+", <b>3M:</b> "+str(three_mins)+str('%')+",<b>5M:</b> "+str(five_mins)+str('%')+", <b>15M:</b> "+str(fifteen_mins)+str('%')+", <b>1H:</b> "+str(one_hours)+str('%')+", <b>3H:</b> "+str(three_hours)+str('%')+", <b>6H:</b> "+str(six_hours)+"%, <b>12H:</b> "+str(twelve_hours)+str('%')
						data='<b>:::'+str(symbol)+str(alert_type)+"\nPrice: </b>"+str(close)+' ('+str(twelve_hours)+'%)'+"\n<b>Volume 24H: </b>"+str(vol24) + "\n<b>Spread:</b> "+str(pdiff)+"%\n<b>BTC Price:</b> "+str(btc_price)+' ('+str(btc_percent)+'%'+')'+"\n"+str(rsi_stats)+"\n"+str(data_add)+"\n"+str(link)

						timestamp=time.time()
						ts_raw=timestamp
						date_time=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
						date_today=str(date.today())							
						alert_key_all=str(date_today)+'-NALERTddsSKdNNBNS'+str(symbol)
						alert_list_today=str(date_today)+'-ALERTLIST'

						symbol_ids=str(symbol)+'-IDS'
						symbol_hash_detailed=str(symbol)+'-'+str(ts_raw)
						
						a=0
						lp=0
								
						alerts=redis_server.lrange(alert_key_all,0,1000)
												
						adata=""
						for alert in alerts:
							alert=alert.decode('utf-8')
							vDate, vPrice, vPer = alert.split("\t")
							if float(vPrice)>float(lp):
								adata=adata+"\n"+str(vDate)+"\t<b>"+str(vPrice)+"</b>\t<b>"+str(vPer)+"</b>"							
								lp=vPrice
							else:
								adata=adata+"\n"+str(vDate)+"\t<i>"+str(vPrice)+"</i>\t"+str(vPer)
							a=1
						
						alerts_key=str(symbol)+str(date_today)+'-ALERTCYCLES'
						alerts_today=redis_server.incr(alerts_key)
						
						#Lets also make a memcache # of alerts so we can have auto expiry time, lets set expiry to two hours "7200 seconds rolling"
						mckey=str(pair)+str("MCALERTS")
						mc.incr(mckey,10800)
						
						grab_mc_counter=0
						
						if mc.get(mckey):
							grab_mc_counter=mc.get(mckey)

						moon=0
						if grab_mc_counter>=5 and percent>3 and fifteen_mins>2:
							mooning=str(symbol)+'-MOONING'
							moon=1
							
						sent=get_sentiment(coin)
						data=data+"\n"+str(sent)
						if a==1:
							data=data+"\n\n<b>TODAYS ALERTS:</b>"+str(adata)

						data=str(data)+"\n\n<b>ALERTS TODAY:</b> "+str(alerts_today)

						data=str(data)+"\n\nThis Alert Was Sent AT: "+str(date_time)+" GMT";
						
						
						sent_buys_percent=float(redis_server.get('SENT-BUYS'))
						sent_sells_percent=float(redis_server.get('SENT-SELLS'))
						sent_price_up_ratio=float(redis_server.get('SENT-PRICE-UP-RATIO'))
						
						nickbot.log_alert(symbol,price,percent,spread,sent_buys_percent,sent_sells_percent,sent_price_up_ratio,alerts_today,fifteen_mins,one_hours,three_hours,six_hours,twelve_hours,link)
							
						#print("DBBBBB")
						#print("LP: ")
						#print(last_price)
						#print("DBBBBB:")
						#print(price)
						pdata=str(date_time)+"\t"+str(price)+"\t"+'('+str(twelve_hours)+'%)'
						
						alert_key_nd=str(coin)+'-ALL-ALERTS'
						redis_server.rpush(alert_key_all,pdata)
						redis_server.rpush(alert_key_nd,pdata)
						redis_server.sadd(alert_list_today,symbol)
						
						#Add Unique Timestamp to list for this symbol, will use as identifer for hash later
						redis_server.sadd(symbol_ids,ts_raw)
							
						detail_hash = {"date":str(date_today),
						"date_time":str(date_time), 
						"symbol":str(symbol), 
						"alert_type":str(alert_type), 
						"price":float(price), 
						"percent":float(percent), 
						"high":str(high), 
						"low":str(low), 
						"volume":int(qv),
						"spread":float(spread),
						"rsi_3mins":float(rsi_3m),
						"rsi_5mins":float(rsi_5m),
						"btc_price":str(btc_price),
						"btc_percent":str(btc_percent),
						"link":str(link),
						}
		
						#print("Writing detailed alert hash data to: "+str(symbol_hash_detailed))
						#print(detail_hash)
						redis_server.hmset(symbol_hash_detailed, detail_hash)

						#print("Pushing coin to todays alert list: "+str(symbol))
						#print(data)
						
						#print("DB RED: set "+str(redis_key)+' last_price'+str(price))
						
						#Blacklist from rebuying a coin for 30 minutes
						blacklisted=0
						blacklisted_key=redis_key+"-BLACKLIST"
						
						rk="bconfig-"+symbol
						blacklisted_key=rk+"-BLACKLIST"

						if redis_server.get(blacklisted_key):
							blacklisted=1
	
						if one_mins>=0.3 or fifteen_mins>1:
							dtoday=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d")
							moonkey=str(dtoday)+'-mooning'
							broadcast_moon('506872080',data)	
							broadcast_moon('446619309',data)
							print("Sent a moon shot alert: key:"+str(moonkey))
							redis_server.sadd(moonkey, symbol)
							
							symbol=symbol.upper()
							ticker_symbol=symbol
							if symbol.endswith('BTC'):
								ticker_symbol = replace_last(ticker_symbol, '/BTC', '')
								trading_to=str('BTC')
							elif symbol.endswith('USDT'):
								ticker_symbol = replace_last(ticker_symbol, '/USDT', '')
								trading_to=str('USDT')
							elif symbol.endswith('BNB'):
								ticker_symbol = replace_last(ticker_symbol, '/BNB', '')
								trading_to=str('BNB')
							elif symbol.endswith('TUSD'):
								ticker_symbol = replace_last(ticker_symbol, '/TUSD', '')
								trading_to=str('TUSD')
							elif symbol.endswith('USD'):
								ticker_symbol = replace_last(ticker_symbol, '/USD', '')
								trading_to=str('USD')
							elif symbol.endswith('USDC'):
								ticker_symbol = replace_last(ticker_symbol, '/USDC', '')
								trading_to=str('USDC')
							elif symbol.endswith('PAX'):
								ticker_symbol = replace_last(ticker_symbol, '/PAX', '')
								trading_to=str('PAX')
							elif symbol.endswith('USDS'):
								ticker_symbol = replace_last(ticker_symbol, '/USDS', '')
								trading_to=str('USDS')
							elif symbol.endswith('ETH'):
								ticker_symbol = replace_last(ticker_symbol, '/ETH', '')
								trading_to=str('ETH')
							trading_from=ticker_symbol
							print("Debug TS: "+str(ticker_symbol))
							#broadcast_moon('506872080',ticker_symbol)	

							moonkey2=str(dtoday)+'-mooning-np'
							redis_server.sadd(moonkey2, ticker_symbol)

							max_bots=10
							#$100 bucks budget per bot
							budget=100
							#Lets Work out the number of units here
							bankinfo=nickbot.work_units(coin,budget)
							units=float(bankinfo["units"])
							balance_needed=float(bankinfo["balance_needed"])
							#Lets check the whole bank roll to see if we got enuff dough for the trade
							balances=exchange.fetch_balance ()
							bank_balance=float(format(balances[trading_to]['total'],'.8f'))
							if bank_balance>=balance_needed:
								
								#lets check we don't have a bot allready running for this shit and that we didn't exceed max amount of bots
								botlist=redis_server.smembers("botlist")
								bots_running=int(len(botlist))
								if gotbot(coin)!=1 and bots_running<=max_bots:					
									bcdb='lets spawn an auto trader bot for '+str(coin)+' budget: '+str(budget)+' Units: '+str(units)
									broadcast_moon('506872080',bcdb)
									broadcast_moon('446619309',data)
									rsi_symbol=str(symbol)
									symbol=str(coin)
									buy_pos=int(0)
									sell_pos=int(0)
									stoploss_percent=float(4)
									use_stoploss=int(1)
									candle_size=str('5m')
									safeguard_percent=float(2)
									rsi_buy=float(20)
									rsi_sell=float(80)
									instant_market_buy=str('yes')
									enable_buybacks=str('no')
									enable_safeguard=str('no')
									force_buy=str('yes')
									force_sell=str('no')
									live=str('yes')
									trading_on=str('Binance')
									key=str(symbol)+'-SYSTEM-STOPLOSS'
									if(mc.get(key)):
										mc.delete(key)
									nickbot.auto_spawn(trading_on, rsi_symbol, symbol, units, ticker_symbol, trading_to, buy_pos, sell_pos, stoploss_percent, use_stoploss, candle_size, safeguard_percent, rsi_buy, rsi_sell, instant_market_buy, enable_buybacks, enable_safeguard, force_buy, force_sell, live)
						print("Sending!!!.."+str(data))
						broadcast('506872080',data)	
						broadcast('693711905',data)	
						broadcast('420441454',data)	
						broadcast('446619309',data)	
						broadcast('490148813',data)	
						broadcast('110880375',data)	
						broadcast('699448304',data)	
						broadcast('593213791',data)	
						broadcast('543018578',data)
						broadcast('503482955',data)
						broadcast('429640253',data)
						broadcast('862193134',data)
						
						time.sleep(0.5)	
		
e=0
while True:
	#try:
	main()
	print("Cycle !!!!!\n")
	#except:
	#e=1
	time.sleep(10)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def price_when(symbol,secs):

	symbol=symbol.replace('/','')
	ksymbol=symbol
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	ts_before = ts_now - datetime.timedelta(seconds=secs)
	ts_end = ts_before + datetime.timedelta(seconds=20)
	print(ts_before)

	ts_before_ts=int(time.mktime(ts_before.timetuple()))
	ts_end_ts=int(time.mktime(ts_end.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_before_ts).strftime("%Y-%m-%d %H:%M:%S")
	print("C")
	print(tsd)	
	redis_key=str(symbol)+'HISTORY'
	print(redis_key)
	print(ts_before_ts)
	print(ts_end_ts)
	
	#redis_server.zrangebyscore(redis_key,symbol,ts_before_ts,ts_end_ts)
	ret=redis_server.zrangebyscore('BTCUSDT-HISTORY',ts_before_ts,ts_end_ts,0,1000)
	size=len(ret)
	if size>0:
		data=ret[0].decode('utf-8')
		ts,price,volume = data.split(":")

		data={}
		data['price']=float(price)
		data['volume']=float(volume)
		return(data)
	else:	
		return("ERROR")
symbol='BTC/PAX'
exchange=nickbot.get_exchange()

tickers=exchange.fetchTickers()
mc = memcache.Client(['127.0.0.1:11211'], debug=0)
#for coin in tickers:
price=float(tickers['BTC/USDT']['close'])
volume=float(tickers['BTC/USDT']['quoteVolume'])

def sell(symbol,percent,stablecoin):
	symbol=symbol.upper()
	balances=exchange.fetch_balance ()
	balance=float(format(balances['BTC']['total'],'.8f'))
	units=units=balance/100*float(percent)
	
	print("Selling: "+str(symbol)+" Units: "+str(units)+" To Stable coin: "+str(stablecoin))
	
sell('BTC','75','PAX')
sys.exit("die")
def store_prices(symbol,price,volume):
	#1Minute
	data=price_when(symbol,60)
	if data!='ERROR':
		price_1min=data['price']
		volume_1min=data['volume']
		good=int(1)
		price_percent_1min=nickbot.diff_percent(price_1min,price)
		volume_percent_1min=nickbot.diff_percent(volume_1min,volume)
	else:
		price_percent_1min=0
		volume_percent_1min=0

	#2Minute
	data=price_when(symbol,120)
	if data!='ERROR':
		price_2min=data['price']
		volume_2min=data['volume']
		good=int(1)
		price_percent_2min=nickbot.diff_percent(price_2min,price)
		volume_percent_2min=nickbot.diff_percent(volume_2min,volume)
	else:
		price_percent_2min=0
		volume_percent_2min=0	

	#3Minute
	data=price_when(symbol,180)
	if data!='ERROR':
		price_3min=data['price']
		volume_3min=data['volume']
		good=int(1)
		price_percent_3min=nickbot.diff_percent(price_3min,price)
		volume_percent_3min=nickbot.diff_percent(volume_3min,volume)
	else:
		price_percent_3min=0
		volume_percent_3min=0
	
	#5Minute
	data=price_when(symbol,300)
	if data!='ERROR':
		price_5min=data['price']
		volume_5min=data['volume']
		good=int(1)
		price_percent_5min=nickbot.diff_percent(price_5min,price)
		volume_percent_5min=nickbot.diff_percent(volume_5min,volume)
	else:
		price_percent_5min=0
		volume_percent_5min=0

	#10Minute
	data=price_when(symbol,600)
	if data!='ERROR':
		price_10min=data['price']
		volume_10min=data['volume']
		good=int(1)
		price_percent_10min=nickbot.diff_percent(price_10min,price)
		volume_percent_10min=nickbot.diff_percent(volume_10min,volume)
	else:
		price_percent_10min=0
		volume_percent_10min=0
	
	#15Minute
	data=price_when(symbol,900)
	if data!='ERROR':
		price_15min=data['price']
		volume_15min=data['volume']
		good=int(1)
		price_percent_15min=nickbot.diff_percent(price_15min,price)
		volume_percent_15min=nickbot.diff_percent(volume_15min,volume)
	else:
		price_percent_15min=0
		volume_percent_15min=0
	
	#30Minute
	data=price_when(symbol,1800)
	if data!='ERROR':
		price_30min=data['price']
		volume_30min=data['volume']
		good=int(1)
		price_percent_30min=nickbot.diff_percent(price_30min,price)
		volume_percent_30min=nickbot.diff_percent(volume_30min,volume)
	else:
		price_percent_30min=0
		volume_percent_30min=0

	#1Hour
	data=price_when(symbol,3600)
	if data!='ERROR':
		price_1hour=data['price']
		volume_1hour=data['volume']
		good=int(1)
		price_percent_1hour=nickbot.diff_percent(price_1hour,price)
		volume_percent_1hour=nickbot.diff_percent(volume_1hour,volume)
	else:
		price_percent_1hour=0
		volume_percent_1hour=0
		
	#1Hour
	data=price_when(symbol,7200)
	if data!='ERROR':
		price_2hour=data['price']
		volume_2hour=data['volume']
		good=int(1)
		price_percent_2hour=nickbot.diff_percent(price_2hour,price)
		volume_percent_2hour=nickbot.diff_percent(volume_2hour,volume)
	else:
		price_percent_2hour=0
		volume_percent_2hour=0
		price_2hour=0
		volume_2hour=0
	
	#3Hour
	data=price_when(symbol,10800)
	if data!='ERROR':
		price_3hour=data['price']
		volume_3hour=data['volume']
		good=int(1)
		price_percent_3hour=nickbot.diff_percent(price_3hour,price)
		volume_percent_3hour=nickbot.diff_percent(volume_3hour,volume)
	else:
		price_percent_3hour=0
		volume_percent_3hour=0
		price_3hour=0
		volume_3hour=0
		
	#6Hour
	data=price_when(symbol,21600)
	if data!='ERROR':
		price_6hour=data['price']
		volume_6hour=data['volume']
		good=int(1)
		price_percent_6hour=nickbot.diff_percent(price_6hour,price)
		volume_percent_6hour=nickbot.diff_percent(volume_6hour,volume)
	else:
		price_percent_6hour=0
		volume_percent_6hour=0
		price_6hour=0
		volume_6hour=0
	
	#12Hour
	data=price_when(symbol,43200)
	if data!='ERROR':
		price_12hour=data['price']
		volume_12hour=data['volume']
		good=int(1)
		price_percent_12hour=nickbot.diff_percent(price_12hour,price)
		volume_percent_12hour=nickbot.diff_percent(volume_12hour,volume)
	else:
		price_percent_12hour=0
		volume_percent_12hour=0
		price_12hour=0
		volume_12hour=0
	
	#24hour
	data=price_when(symbol,86400)
	if data!='ERROR':
		price_24hour=data['price']
		volume_24hour=data['volume']
		good=int(1)
		price_percent_24hour=nickbot.diff_percent(price_24hour,price)
		volume_percent_24hour=nickbot.diff_percent(volume_24hour,volume)
	else:
		price_percent_24hour=0
		volume_percent_24hour=0
		price_24hour=0
		volume_24hour=0
	
	prices = {
		"price-1min":str(price_1min),
		"price-percent-1min":str(price_percent_1min), 
		"volume-1min":str(volume_1min),
		"volume-percent-1min":str(volume_percent_1min),			
		"price-2min":str(price_2min),
		"price-percent-2min":str(price_percent_2min), 
		"volume-2min":str(volume_2min),
		"volume-percent-2min":str(volume_percent_2min),
		"price-3min":str(price_3min),
		"price-percent-3min":str(price_percent_3min), 
		"volume-3min":str(volume_3min),
		"volume-percent-3min":str(volume_percent_3min),
		"price-5min":str(price_5min),
		"price-percent-5min":str(price_percent_5min), 
		"volume-5min":str(volume_5min),
		"volume-percent-5min":str(volume_percent_5min),
		"price-10min":str(price_10min),
		"price-percent-10min":str(price_percent_10min), 
		"volume-10min":str(volume_10min),
		"volume-percent-10min":str(volume_percent_10min),
		"price-15min":str(price_15min),
		"price-percent-15min":str(price_percent_15min), 
		"volume-15min":str(volume_15min),
		"volume-percent-15min":str(volume_percent_15min),
		"price-30min":str(price_30min),
		"price-percent-30min":str(price_percent_30min), 
		"volume-30min":str(volume_30min),
		"volume-percent-30min":str(volume_percent_30min),
		"price-1hour":str(price_1hour),
		"price-percent-1hour":str(price_percent_1hour), 
		"volume-1hour":str(volume_1hour),
		"volume-percent-1hour":str(volume_percent_1hour),
		"price-2hour":str(price_2hour),
		"price-percent-2hour":str(price_percent_2hour), 
		"volume-2hour":str(volume_2hour),
		"volume-percent-2hour":str(volume_percent_2hour),
		"price-3hour":str(price_3hour),
		"price-percent-3hour":str(price_percent_3hour), 
		"volume-3hour":str(volume_3hour),
		"volume-percent-3hour":str(volume_percent_3hour),
		"price-6hour":str(price_6hour),
		"price-percent-6hour":str(price_percent_6hour), 
		"volume-6hour":str(volume_6hour),
		"volume-percent-6hour":str(volume_percent_6hour),
		"price-12hour":str(price_12hour),
		"price-percent-12hour":str(price_percent_12hour), 
		"volume-12hour":str(volume_12hour),
		"volume-percent-12hour":str(volume_percent_12hour),
		"price-24hour":str(price_24hour),
		"price-percent-24hour":str(price_percent_24hour), 
		"volume-24hour":str(volume_24hour),
		"volume-percent-24hour":str(volume_percent_24hour)}
	redis_key=symbol+'-STATS'
	redis_server.hmset(redis_key, prices)
print(prices)
import os
from collections import OrderedDict
import requests
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import talib
import numpy as np
import ccxt
import redis
import datetime
import configparser
import subprocess
import time
import shlex
import argparse
import heapq

config = configparser.ConfigParser()
config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database='cmc'
telegram_id=config['binance']['TEEGRAM_ID_EMBED']

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')
	
r = redis.Redis(host='localhost', port=6379, db=0)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def broadcast_tether_trade(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['AUTO_TETHERBOT_TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content	

def broadcast_tether(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TETHERBOT_TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content	

def broadcast_moon(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['MOON_TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content	

def log_alert(symbol,price,percent,spread,sent_buys_percent,sent_sells_percent,sent_price_up_ratio,alerts,percent_15m,percent_1h,percent_3h,percent_6h,percent_12h,link):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO at_alerts(date,date_time,timestamp,symbol,price,percent,spread,sent_buys_percent,sent_sells_percent,sent_price_up_ratio,alerts,percent_15m,percent_1h,percent_3h,percent_6h,percent_12h,link) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	""")

	cursor.execute(sql,(symbol,price,percent,spread,sent_buys_percent,sent_sells_percent,sent_price_up_ratio,alerts,percent_15m,percent_1h,percent_3h,percent_6h,percent_12h,link))
	db.close()

def log_autotether_trades(symbol,price,units,percent,action,reason):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO autotether_trades(date,date_time,timestamp,symbol,price,units,percent,action,reason) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s)
	""")

	cursor.execute(sql,(symbol,price,units,percent,action,reason))
	db.close()

def log_autotether_stats(symbol,price,percent_1min,percent_2min,percent_3min,percent_5min,percent_10min,percent_15min,percent_30min,percent_1hour,percent_3hour,percent_6hour,percent_12hour,percent_24hour,rsi):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO autotether_stats(date,date_time,timestamp,symbol,price,percent_1min,percent_2min,percent_3min,percent_5min,percent_10min,percent_15min,percent_30min,percent_1hour,percent_3hour,percent_6hour,percent_12hour,percent_24hour,rsi) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	""")

	cursor.execute(sql,(symbol,price,percent_1min,percent_2min,percent_3min,percent_5min,percent_10min,percent_15min,percent_30min,percent_1hour,percent_3hour,percent_6hour,percent_12hour,percent_24hour,rsi))
	db.close()
	
	
def log_binance(symbol,price,percent,spread,low,high,volume,btc_price,btc_percent):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO binance_stats(date,date_time,timestamp,symbol,price,percent,spread,low,high,volume,btc_price,btc_percent) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s)
	""")

	cursor.execute(sql,(symbol,price,percent,spread,low,high,volume,btc_price,btc_percent))
	db.close()

def log_order(exchange,bot_id,order_id,order_type,symbol,rsi_symbol,trade_from,trade_to,sell_price,units):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	order_array=fetch_last_buy_order(exchange,symbol)
	buy_price=float(order_array['price'])
	
	profit_per_unit=sell_price-buy_price
	profit=float(profit_per_unit*units)
	profit=round(profit,8)
	prices = [buy_price,sell_price]
	for a, b in zip(prices[::1], prices[1::1]):
		profit_percent=100 * (b - a) / a
		profit_percent=round(profit_percent,2)

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO at_orders(date,date_time,timestamp,bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	""")

	print(bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent)

	cursor.execute(sql,(bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent))
	db.close()
	
def get_exchange():
	
	#Read in our apikeys and accounts
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	conf=config['binance']
	
	binance_api_key=config['binance']['API_KEY']
	binance_api_secret=config['binance']['API_SECRET']
	
	exchange = ccxt.binance({
    'apiKey': binance_api_key,
    'secret': binance_api_secret,
    'enableRateLimit': True,
    'rateLimit': 3600,
    'verbose': False,  # switch it to Fal_se if you don't want the HTTP log
	})
	return(exchange)

def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)


def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

def diff_percent(low,high
	):
	low=float(low)
	high=float(high)
	prices = [low,high]
	for a, b in zip(prices[::1], prices[1::1]):
		pdiff=100 * (b - a) / a
	pdiff=round(pdiff,4)

	return(pdiff)


def get_price(exchange,symbol):
	
	symbol=symbol.upper()	
	ticker = exchange.fetch_ticker(symbol.upper())
	print(str(ticker))
	price=float(ticker['last'])
	return(price)

def price_when(symbol,secs):

	symbol=symbol.replace('/','')
	ksymbol=symbol
	ts_now = datetime.datetime.now()
	ts_now_ts=int(time.mktime(ts_now.timetuple()))	
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	ts_before = ts_now - datetime.timedelta(seconds=secs)
	ts_end = ts_before + datetime.timedelta(seconds=20)
	#print(ts_before)

	ts_before_ts=int(time.mktime(ts_before.timetuple()))
	ts_end_ts=int(time.mktime(ts_end.timetuple()))
	tsd=datetime.datetime.fromtimestamp(ts_before_ts).strftime("%Y-%m-%d %H:%M:%S")
	#print("C")
	#print(tsd)	
	redis_key=str(symbol)+'-HISTORY'
	#print(redis_key)
	#print(ts_before_ts)
	#print(ts_end_ts)
	
	#redis_server.zrangebyscore(redis_key,symbol,ts_before_ts,ts_end_ts)
	ret=redis_server.zrangebyscore(redis_key,ts_before_ts,ts_end_ts,0,1000)
	size=len(ret)
	if size>0:
		data=ret[0].decode('utf-8')
		ts,price,volume = data.split(":")

		data={}
		price=round(float(price),2)
		volume=round(float(volume),2)
				
		data['price']=float(price)
		data['volume']=float(volume)
		return(data)
	else:	
		return("ERROR")

def get_rsi(pair,interval):
	rsi_symbol=pair
	rsi_symbol=rsi_symbol.replace('/','')
	
	arr = []
	out = []
	fin = []
	url="https://api.binance.com/api/v1/klines?symbol="+rsi_symbol+"&interval="+interval+"&limit=500"
	#print(url)
	r=requests.get(url)
	res = (r.content.strip())
	status = r.status_code
	#print("Status: "+str(status))
	rsi_status=''
	trades = json.loads(res.decode('utf-8'))

	lp=0
	for trade in trades:
		open_price=float(trade[0])
		close_price=float(trade[4])
		high_price=float(trade[2])
		low_price=float(trade[3])
		if close_price>0 and close_price!=lp:
			arr.append(close_price)	
		lp=close_price

	np_arr = np.array(arr,dtype=float)
	output=talib.RSI(np_arr,timeperiod=15)

	for chkput in output:
		if chkput>0:
			fin.append(chkput)
		
	rsi=float(fin[-1])
	rsi=round(rsi)
	return(rsi)

def store_prices(symbol,price,volume):
	#1Minute
	data=price_when(symbol,60)
	if data!='ERROR':
		price_1min=data['price']
		volume_1min=data['volume']
		good=int(1)
		price_percent_1min=diff_percent(price_1min,price)
		volume_percent_1min=diff_percent(volume_1min,volume)
	else:
		price_percent_1min=0
		volume_percent_1min=0
		price_1min=0
		volume_1min=0

	#2Minute
	data=price_when(symbol,120)
	if data!='ERROR':
		price_2min=data['price']
		volume_2min=data['volume']
		good=int(1)
		price_percent_2min=diff_percent(price_2min,price)
		volume_percent_2min=diff_percent(volume_2min,volume)
	else:
		price_percent_2min=0
		volume_percent_2min=0	
		price_2min=0
		volume_2min=0


	#3Minute
	data=price_when(symbol,180)
	if data!='ERROR':
		price_3min=data['price']
		volume_3min=data['volume']
		good=int(1)
		price_percent_3min=diff_percent(price_3min,price)
		volume_percent_3min=diff_percent(volume_3min,volume)
	else:
		price_percent_3min=0
		volume_percent_3min=0
		price_3min=0
		volume_3min=0

	
	#5Minute
	data=price_when(symbol,300)
	if data!='ERROR':
		price_5min=data['price']
		volume_5min=data['volume']
		good=int(1)
		price_percent_5min=diff_percent(price_5min,price)
		volume_percent_5min=diff_percent(volume_5min,volume)
	else:
		price_percent_5min=0
		volume_percent_5min=0
		price_5min=0
		volume_5min=0

	#10Minute
	data=price_when(symbol,600)
	if data!='ERROR':
		price_10min=data['price']
		volume_10min=data['volume']
		good=int(1)
		price_percent_10min=diff_percent(price_10min,price)
		volume_percent_10min=diff_percent(volume_10min,volume)
	else:
		price_percent_10min=0
		volume_percent_10min=0
		price_10min=0
		volume_10min=0

	#15Minute
	data=price_when(symbol,900)
	if data!='ERROR':
		price_15min=data['price']
		volume_15min=data['volume']
		good=int(1)
		price_percent_15min=diff_percent(price_15min,price)
		volume_percent_15min=diff_percent(volume_15min,volume)
	else:
		price_percent_15min=0
		volume_percent_15min=0
		price_15min=0
		volume_15min=0

	
	#30Minute
	data=price_when(symbol,1800)
	if data!='ERROR':
		price_30min=data['price']
		volume_30min=data['volume']
		good=int(1)
		price_percent_30min=diff_percent(price_30min,price)
		volume_percent_30min=diff_percent(volume_30min,volume)
	else:
		price_percent_30min=0
		volume_percent_30min=0
		price_30min=0
		volume_30min=0

	#1Hour
	price_1hour=int(0)
	volume_1hour=int(0)
	
	price_2hour=int(0)
	volume_2hour=int(0)

	price_3hour=int(0)
	volume_3hour=int(0)
		
	price_6hour=int(0)
	volume_6hour=int(0)
	
	price_12hour=int(0)
	volume_12hour=int(0)

	price_24hour=int(0)
	volume_24hour=int(0)
	
	data=price_when(symbol,3600)
	if data!='ERROR':
		price_1hour=data['price']
		volume_1hour=data['volume']
		good=int(1)
		price_percent_1hour=diff_percent(price_1hour,price)
		volume_percent_1hour=diff_percent(volume_1hour,volume)
	else:
		price_percent_1hour=0
		volume_percent_1hour=0
		price_1hour=0
		
	#1Hour
	data=price_when(symbol,7200)
	if data!='ERROR':
		price_2hour=data['price']
		volume_2hour=data['volume']
		good=int(1)
		price_percent_2hour=diff_percent(price_2hour,price)
		volume_percent_2hour=diff_percent(volume_2hour,volume)
	else:
		price_percent_2hour=0
		volume_percent_2hour=0
		price_2hour=0
		volume_2hour=0
	
	#3Hour
	data=price_when(symbol,10800)
	if data!='ERROR':
		price_3hour=data['price']
		volume_3hour=data['volume']
		good=int(1)
		price_percent_3hour=diff_percent(price_3hour,price)
		volume_percent_3hour=diff_percent(volume_3hour,volume)
	else:
		price_percent_3hour=0
		volume_percent_3hour=0
		price_3hour=0
		volume_3hour=0
		
	#6Hour
	data=price_when(symbol,21600)
	if data!='ERROR':
		price_6hour=data['price']
		volume_6hour=data['volume']
		good=int(1)
		price_percent_6hour=diff_percent(price_6hour,price)
		volume_percent_6hour=diff_percent(volume_6hour,volume)
	else:
		price_percent_6hour=0
		volume_percent_6hour=0
		price_6hour=0
		volume_6hour=0
	
	#12Hour
	data=price_when(symbol,43200)
	if data!='ERROR':
		price_12hour=data['price']
		volume_12hour=data['volume']
		good=int(1)
		price_percent_12hour=diff_percent(price_12hour,price)
		volume_percent_12hour=diff_percent(volume_12hour,volume)
	else:
		price_percent_12hour=0
		volume_percent_12hour=0
		price_12hour=0
		volume_12hour=0
	
	#24hour
	data=price_when(symbol,86400)
	if data!='ERROR':
		price_24hour=data['price']
		volume_24hour=data['volume']
		good=int(1)
		price_percent_24hour=diff_percent(price_24hour,price)
		volume_percent_24hour=diff_percent(volume_24hour,volume)
	else:
		price_percent_24hour=0
		volume_percent_24hour=0
		price_24hour=0
		volume_24hour=0
	
	prices = {
		"price-1min":str(price_1min),
		"price-percent-1min":str(price_percent_1min), 
		"volume-1min":str(volume_1min),
		"volume-percent-1min":str(volume_percent_1min),			
		"price-2min":str(price_2min),
		"price-percent-2min":str(price_percent_2min), 
		"volume-2min":str(volume_2min),
		"volume-percent-2min":str(volume_percent_2min),
		"price-3min":str(price_3min),
		"price-percent-3min":str(price_percent_3min), 
		"volume-3min":str(volume_3min),
		"volume-percent-3min":str(volume_percent_3min),
		"price-5min":str(price_5min),
		"price-percent-5min":str(price_percent_5min), 
		"volume-5min":str(volume_5min),
		"volume-percent-5min":str(volume_percent_5min),
		"price-10min":str(price_10min),
		"price-percent-10min":str(price_percent_10min), 
		"volume-10min":str(volume_10min),
		"volume-percent-10min":str(volume_percent_10min),
		"price-15min":str(price_15min),
		"price-percent-15min":str(price_percent_15min), 
		"volume-15min":str(volume_15min),
		"volume-percent-15min":str(volume_percent_15min),
		"price-30min":str(price_30min),
		"price-percent-30min":str(price_percent_30min), 
		"volume-30min":str(volume_30min),
		"volume-percent-30min":str(volume_percent_30min),
		"price-1hour":str(price_1hour),
		"price-percent-1hour":str(price_percent_1hour), 
		"volume-1hour":str(volume_1hour),
		"volume-percent-1hour":str(volume_percent_1hour),
		"price-2hour":str(price_2hour),
		"price-percent-2hour":str(price_percent_2hour), 
		"volume-2hour":str(volume_2hour),
		"volume-percent-2hour":str(volume_percent_2hour),
		"price-3hour":str(price_3hour),
		"price-percent-3hour":str(price_percent_3hour), 
		"volume-3hour":str(volume_3hour),
		"volume-percent-3hour":str(volume_percent_3hour),
		"price-6hour":str(price_6hour),
		"price-percent-6hour":str(price_percent_6hour), 
		"volume-6hour":str(volume_6hour),
		"volume-percent-6hour":str(volume_percent_6hour),
		"price-12hour":str(price_12hour),
		"price-percent-12hour":str(price_percent_12hour), 
		"volume-12hour":str(volume_12hour),
		"volume-percent-12hour":str(volume_percent_12hour),
		"price-24hour":str(price_24hour),
		"price-percent-24hour":str(price_percent_24hour), 
		"volume-24hour":str(volume_24hour),
		"volume-percent-24hour":str(volume_percent_24hour)}
	redis_key=symbol+'-STATS'
	redis_server.hmset(redis_key, prices)
	return(prices)
	
def v24_usd_alerts_cached(exchange,symbol,v24):

	symbol=symbol.upper()


	if symbol.endswith('BTC'):
		key=str(symbol)+'-BTC-USDT-PRICE'
		if r.get(key):
			trade_to_price=r.get(key)
		else:
			tickers=fetch_prices(exchange,'BTC/USDT')
			trade_to_price=float(tickers['close'])
			r.setex(key,120,trade_to_price)
	elif symbol.endswith('ETH'):
		key=str(symbol)+'-ETH-USDT-PRICE'
		if r.get(key):
			trade_to_price=r.get(key)
		else:
			tickers=fetch_prices(exchange,'ETH/USDT')
			trade_to_price=float(tickers['close'])
			r.setex(key,120,trade_to_price)
	elif symbol.endswith('BNB'):
		key=str(symbol)+'-BNB-USDT-PRICE'
		if r.get(key):
			trade_to_price=r.get(key)
		else:
			tickers=fetch_prices(exchange,'BNB/USDT')
			trade_to_price=float(tickers['close'])
			r.setex(key,120,trade_to_price)
	else:
		trade_to_price=1
	trade_to_price=float(trade_to_price)
	p24=v24*trade_to_price
	p24=float(p24)
	
	return(p24)

def volume24h_in_usd(symbol):

	exchange=get_exchange()

	symbol=symbol.upper()
	ticker_symbol=symbol
	tickers=fetch_prices(exchange,ticker_symbol)

	v24=tickers['quoteVolume']

	if symbol.endswith('BTC'):
		tickers=fetch_prices(exchange,'BTC/USDT')
		trade_to_price=float(tickers['close'])
	elif symbol.endswith('ETH'):
		tickers=fetch_prices(exchange,'ETH/USDT')
		trade_to_price=float(tickers['close'])
	elif symbol.endswith('BNB'):
		tickers=fetch_prices(exchange,'BNB/USDT')
		trade_to_price=float(tickers['close'])
	else:
		trade_to_price=1

	p24=v24*trade_to_price
	p24=float(p24)
	
	return(p24)
	
def price_usd(symbol):

	symbol=symbol.upper()
	ticker_symbol=symbol

	if symbol.endswith('BTC'):
		ticker_symbol = replace_last(ticker_symbol, '/BTC', '')
		trade_to='BTC'
	elif symbol.endswith('USDT'):
		ticker_symbol = replace_last(ticker_symbol, '/USDT', '')
		trade_to='USDT'
	elif symbol.endswith('BNB'):
		ticker_symbol = replace_last(ticker_symbol, '/BNB', '')
		trade_to='BNB'
	elif symbol.endswith('TUSD'):
		ticker_symbol = replace_last(ticker_symbol, '/TUSD', '')
		trade_to='TUSD'
	elif symbol.endswith('USD'):
		ticker_symbol = replace_last(ticker_symbol, '/USD', '')
		trade_to='USD'
	elif symbol.endswith('USDC'):
		ticker_symbol = replace_last(ticker_symbol, '/USDC', '')
		trade_to='USDC'
	elif symbol.endswith('PAX'):
		ticker_symbol = replace_last(ticker_symbol, '/PAX', '')
		trade_to='PAX'
	elif symbol.endswith('USDS'):
		ticker_symbol = replace_last(ticker_symbol, '/USDS', '')
		trade_to='USDS'
	elif symbol.endswith('ETH'):
		ticker_symbol = replace_last(ticker_symbol, '/ETH', '')
		trade_to='ETH'
	
	trade_from=ticker_symbol
	exchange=get_exchange()
	
	pair_price=0
	budget=1
	if trade_to=='ETH':
		tickers=fetch_prices(exchange,'ETH/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	elif trade_to=='BTC':
		tickers=fetch_prices(exchange,'BTC/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	elif trade_to=='BNB':
		tickers=fetch_prices(exchange,'BNB/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	else:
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])

	pair_price=float(pair_price)
	return(pair_price)

def wall_magic(symbol,last_stoploss):
	
	exchange=get_exchange()
	book=fetch_order_book(exchange,symbol,'bids','1000')
	#New JEdimaster shit lets have at least $100k above us in buy order book set our dynamic stoploss @ that position in the book
	
	vol24=float(volume24h_in_usd(symbol))
	if vol24>100000000:
		vlimit=vol24/100*0.2
	elif vol24>50000000 and vol24<100000000:
		vlimit=vol24/100*0.5
	elif vol24>25000000 and vol24<50000000:
		vlimit=vol24/100*0.5
	else:
		vlimit=vol24/100*0.5
	print(symbol)
		
	sl_pos=wall_pos(symbol,vlimit)
	
	print("LAST STOPLOSS: "+str(last_stoploss))
	print("STOPLOSS POSITION: "+str(sl_pos))
	
	rkt=symbol+"TTT"
	r.setex(rkt,15,sl_pos)
	
	redis_key="bconfig-"+symbol
	wall_stoploss=float(book[sl_pos][0])
	if not wall_stoploss:
		sl_pos=wall_pos(symbol,100000)		
		wall_stoploss=float(book[sl_pos][0])
	print("WSL: "+str(wall_stoploss))
	print("VOLUME V24: "+str(vol24))
	print("VLIMIT: "+str(vlimit))
	
	r.hset(redis_key, 'wall_stoploss',wall_stoploss)
	
	return(wall_stoploss)


def wall_pos(symbol,usd_limit):
	
	#Fucking jedi master shit, lets make sure that theres usd_limit above us in the buy book @ set our dynamic stoploss at that
	usd_limit=float(usd_limit)
	pusd=float(price_usd(symbol))
	exchange=get_exchange()
	message=""
	buy_book=exchange.fetch_order_book(symbol,1000)
	pos=int(0)
	book=buy_book['bids']
	tv_usd=0
	got=0
	print("USD LIMIT: "+str(usd_limit))
	for line in book:
		k=line[0]
		v=line[1]
		v_usd=round(float(v)*pusd,2)
		tv_usd=round(float(tv_usd+v_usd),2)
		#print("DEBUG K: "+str(k))
		#print("DEBUG TVUSD: "+str(tv_usd))
		#print("DEBUG USDLIMIT: "+str(usd_limit))
		#if k>=float(stoploss):
		#message=message+"BOOK POS: "+str(pos)+"\tPRICE: "+str(k)+"\tVOLUME: "+str(v)+"\tVOLUME USD: "+str(v_usd)+"\tTOTAL VOLUME USD: "+str(tv_usd)+"\n"
		#print(message)
		if tv_usd>=usd_limit:
			print(message)
			return(pos)
			got=1	
		
		if got!=1:
			pos+=1
			
	return(pos)		
	print(message)
	
def broadcast(chatid,text):
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')
	telegram_id=config['binance']['TELEGRAM_ID']
	token = telegram_id
	url = "https://api.telegram.org/"+ token + "/sendMessage?chat_id=" + chatid+"&text="+str(text)+"&parse_mode=HTML"
	r=requests.get(url)
	html = r.content
	print(html)

def work_units(symbol,budget):

	symbol=symbol.upper()
	ticker_symbol=symbol

	if symbol.endswith('BTC'):
		ticker_symbol = replace_last(ticker_symbol, '/BTC', '')
		trade_to='BTC'
	elif symbol.endswith('USDT'):
		ticker_symbol = replace_last(ticker_symbol, '/USDT', '')
		trade_to='USDT'
	elif symbol.endswith('BNB'):
		ticker_symbol = replace_last(ticker_symbol, '/BNB', '')
		trade_to='BNB'
	elif symbol.endswith('TUSD'):
		ticker_symbol = replace_last(ticker_symbol, '/TUSD', '')
		trade_to='TUSD'
	elif symbol.endswith('USD'):
		ticker_symbol = replace_last(ticker_symbol, '/USD', '')
		trade_to='USD'
	elif symbol.endswith('USDC'):
		ticker_symbol = replace_last(ticker_symbol, '/USDC', '')
		trade_to='USDC'
	elif symbol.endswith('PAX'):
		ticker_symbol = replace_last(ticker_symbol, '/PAX', '')
		trade_to='PAX'
	elif symbol.endswith('USDS'):
		ticker_symbol = replace_last(ticker_symbol, '/USDS', '')
		trade_to='USDS'
	elif symbol.endswith('ETH'):
		ticker_symbol = replace_last(ticker_symbol, '/ETH', '')
		trade_to='ETH'
	
	trade_from=ticker_symbol
	exchange=get_exchange()
	
	pair_price=0
	if trade_to=='ETH':
		tickers=fetch_prices(exchange,'ETH/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price	
	elif trade_to=='BTC':
		tickers=fetch_prices(exchange,'BTC/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
	elif trade_to=='BNB':
		tickers=fetch_prices(exchange,'BNB/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
	else:
		trade_to_price=int(1)
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		
	#print("Trading From: "+str(trade_from))
	#print("Trade To: "+str(trade_to))
	#print(str(trade_to)+ "Price: "+str(trade_to_price))
	#print("Pair Price: "+str(pair_price))
	#print("Fraction Of "+str(trade_to)+" To "+str(budget)+" is: "+str(fraction_to_budget))
	#print("Units to Execute is: "+str(units))	
	
	bankinfo = {"units":str(units),
	"balance_needed":str(fraction_to_budget)}
	
	return(bankinfo)

def fetch_last_buy_order(exchange,symbol):
	
	ret=exchange.fetch_closed_orders (symbol, 10);
	if ret:
		for order in ret:
			data=order['info']
			side=data['side']
			price=float(data['price'])
			if side=="BUY":
				bdata=data
		return(bdata)
	else:
		print("returning: NULL")
		return("NULL")

def trade_time(exchange,symbol):
	
	trades=exchange.fetchTrades (symbol)
	
	c=0
	for dat in trades:
		ts=dat['timestamp']	
		if c==0:
			start_ts=ts/1000
	last_ts=ts/1000
	c+=1
	elapsed = last_ts - start_ts
	elapsed=float(elapsed)/60
	return(elapsed)

def fetch_last_order(exchange,symbol):
	#print("passed: "+str(symbol))
	ret=exchange.fetch_closed_orders (symbol, 1);
	#print(ret)
	if ret:
		
		data=ret[-1]['info']
		side=data['side']
		price=float(data['price'])
		print("returning: 1")
		return data
	else:
		print("returning: NULL")
		return("NULL")

def spawn_bot(symbol):
	
	config = configparser.ConfigParser()
	
	bfn=str(symbol.lower())+'.ini'
	bfn=bfn.replace("/", "-")
	
	bot_name='watcher:'+str(symbol)
	bot_file='/home/crypto/cryptologic/pid-configs/init.ini'
	args='--trading_pair '+str(symbol)

	#If we allready have this bot in the circus ini don't add it again
	config.read(bot_file)

	if not config.has_section(bot_name):
	
		config.add_section(bot_name)
		config.set(bot_name, 'cmd', '/usr/bin/python3.6 /home/crypto/cryptologic/bots/autotrader.py')
		config.set(bot_name, 'args', args)
		config.set(bot_name, 'warmup_delay', '0')
		config.set(bot_name, 'numprocesses', '1')

		with open(bot_file, 'w') as configfile:
			configfile.write("\n")
			config.write(configfile)
			print("Write Config File to: "+str(bot_file))
			print("Wrote: "+str(configfile))

		subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def fetch_order_book(exchange,symbol,type,qlimit):
	#limit = 1000
	ret=exchange.fetch_l2_order_book(symbol, qlimit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def auto_spawn(trading_on,rsi_symbol, symbol, units, trade_from, trade_to, buy_pos, sell_pos, stoploss_percent, use_stoploss, candle_size, safeguard_percent, rsi_buy, rsi_sell, instant_market_buy, enable_buybacks, enable_safeguard, force_buy, force_sell, live):

	bot_name=symbol

	r = redis.Redis(host='localhost', port=6379, db=0)
	
	bot_ts=time.time()
	bot_config = {"trading_on":str(trading_on),
	"rsi_symbol":str(rsi_symbol), 
	"symbol":str(bot_name), 
	"units":float(units), 
	"trade_from":str(trade_from), 
	"trade_to":str(trade_to), 
	"buy_pos":int(buy_pos),
	"sell_pos":int(sell_pos),
	"stoploss_percent":float(stoploss_percent),
	"use_stoploss":use_stoploss,
	"candle_size":str(candle_size),
	"safeguard_percent":float(safeguard_percent),
	"rsi_buy":float(rsi_buy),
	"rsi_sell":float(rsi_sell),
	"instant_market_buy":str(instant_market_buy),
	"enable_buybacks":str(enable_buybacks),
	"enable_safeguard":str(enable_safeguard),
	"force_buy":str(force_buy),
	"force_sell":str(force_sell),
	"bot_ts":str(bot_ts),
	"live":str(live)}
	
	all=bot_config
	print(bot_config)
	ksymbol=str(symbol)

	redis_key="bconfig-tmp"
	r.hmset(redis_key, bot_config)
	
	bot_name=symbol
		
	r.sadd("botlist", bot_name)
	timestamp=time.time()

	r.set(symbol,timestamp)
	running=datetime.datetime.fromtimestamp(timestamp).strftime("%A, %B %d, %Y %I:%M:%S")

	timestamp=time.time()
	ts_raw=timestamp
	running=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
			
	redis_key="bconfig-"+symbol
		
	r.hmset(redis_key, all)
	bid=r.incr("bids")
	r.hset(redis_key,"id",bid)

	if force_buy=="yes":
		mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
		key=symbol+"-FORCE-BUY"
		mc.set(key,force_buy,86400)			

	elif force_sell=="yes":
		mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
		key=symbol+"-FORCE-SELL"
		mc.set(key,force_sell,86400)			

	if instant_market_buy=="yes":
		exchange=get_exchange()
		buy_book=fetch_order_book(exchange,symbol,'bids','1000')
		buy_pos=int(buy_pos)
		buy_price=float(buy_book[buy_pos][0])
		print(symbol+" Units Buy Price"+str(buy_price))
		
		redis_order_log="ORDERLOG-"+symbol

		ret=exchange.create_order (symbol, 'limit', 'buy', units, buy_price)
		
		order_id=int(ret['info']['orderId'])

		m=str(bid)+"\t"+str(order_id)+"\tBUY\t"+str(symbol)+"\t"+str(rsi_symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(buy_price)+"\t"+str(units)
		print(ret)			
	spawn_bot(symbol)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

exchange=nickbot.get_exchange()	

config = configparser.ConfigParser()

config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database=config['mysql']['MYSQL_DATABASE']

print(mysql_hostname)
print(mysql_username)
print(mysql_password)
print(mysql_database)

db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
cur = db.cursor()
	
query='select * from at_analysis'
cur.execute(query)
db.commit()
result = cur.fetchall()
for row in result:
	id=row[0]
	date=row[1]
	start_date_time=row[2]
	end_date_time=row[3]
	start_timestamp=int(row[4])
	end_timestamp=int(row[5])
	duration_secs=int(row[6])
	bot_id=int(row[7])
	order_id=str(row[8])
	symbol=str(row[9])	
	rsi_symbol=str(row[10])
	trade_from=str(row[11])
	trade_to=str(row[12])
	units=int(row[13])
	buy_price=int(row[14])
	sell_price=int(row[15])
	profit=float(row[16])
	profit_percent=float(row[17])
	bot_profit_high=float(row[18])			
	bot_profit_high_percent=float(row[19])			
	invest_start=float(row[20])
	invest_end=float(row[21])
	
	message=":::BOT " +str(symbol)
	message=message+"\nSTART TIME: "+str(start_date_time)
	message=message+"\nEND TIME: "+str(end_date_time)
	message=message+"\nRAN FOR: "+str(duration_secs)+" SECS"	
	message=message+str("\nBUY PRICE: ")+str(buy_price)+"\nSELL PRICE: "+str(sell_price)+"\nUNITS: "+str(units)
	message=message+"\nVALUE START: "+str(invest_end)
	message=message+"\nVALUE NOW: "+str(invest_end)
	message=message+"\nP&L: "+str(profit)+' ('+str(profit_percent)+'%)'
	message=message+"\nP&L HIGHS: "+str(bot_profit_high)+' ('+str(bot_profit_high_percent)+'%)'
	message=message+"\nBOT ID: "+str(bot_id)
	print(message)
db.close() 
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import redis
import configparser
import datetime
import heapq
import nickbot

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

#checkposts

r = redis.Redis(host='localhost', port=6379, db=0)

botlist=r.smembers("botlist")

print(":::STOPLOSS/MOVER Polling Running Bots\n")

import ccxt  # noqa: E402
				
exchange=nickbot.get_exchange()

def loop_bots():
	
	exchange=nickbot.get_exchange()
	botlist=r.smembers("botlist")
	
	for bot_name in botlist:
	
		buy_array=float(0.0)
		new_stoploss=float(0.0)
		last_stoploss=float(0.0)
		market_price=float(0.0)

		bot_name=bot_name.decode('utf-8')
		symbol=bot_name.upper()
		print(str(symbol))

		orders = exchange.fetch_open_orders(symbol,1)

		#IF theres still an open order no bot shit here
		open_order=len(orders)
		if open_order:
			continue

		ts=float(r.get(bot_name))
		running=datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")
		redis_key="bconfig-"+symbol		
		last_stoploss=0
		all=r.hgetall(redis_key)
		
		trade_from=r.hget(redis_key,'trade_from').decode('utf-8')
		trade_to=r.hget(redis_key,'trade_to').decode('utf-8')
		bot_id=r.hget(redis_key,'id').decode('utf-8')
		
		revkey='REVERSE-'+str(bot_id)
		#print("Debut Setting "+str(revkey)+"to: "+str(symbol))
		r.set(revkey,symbol)				

		ts=float(r.get(bot_name).decode('utf-8'))				
		running=datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")				
		
		key=str(symbol)+'-TRADES'	
		
		key=str(symbol)+'-LAST-PRICE'
		if r.get(key):
			market_price=float(r.get(key))
			print("SLDB MP: "+str(market_price))
		
		t_key="TTT-"+str(symbol)
		
		if mc.get(t_key):
			buy_array=mc.get(t_key)
		else:
			#Cache last order in ram for 60 seconds to speed up api calls
			buy_array=nickbot.fetch_last_buy_order(exchange,symbol)
		#if r.get(t_key):
		#	buy_array=r.get(t_key)
		#else:
		#Cache last order in ram for 60 seconds to speed up api calls
		#buy_array=nickbot.fetch_last_buy_order(exchange,symbol)
		#r.set(t_key,buy_array)
		
		print("BA: ")
		print(buy_array)
		print(str(symbol)+":::START!!!!!!!!!!!!\n\n")
		
		if buy_array!='NULL':
			units=float(buy_array['executedQty'])
			
			if buy_array['type']=='MARKET':
				print(buy_array)	
				buy_price=float(buy_array['cummulativeQuoteQty'])/units
				print("BUY PRICE: "+str(buy_price))
			else:
				buy_price=float(buy_array['price'])
				print("BUY PRICE: "+str(buy_price))

			print("MARKET PRICE: "+str(market_price))
			profit_per_unit=float(market_price)-float(buy_price)
			profit_total=float(profit_per_unit*units)
			profit_total=round(profit_total,8)
			prices = [buy_price,market_price]
			for a, b in zip(prices[::1], prices[1::1]):
				percent=100 * (b - a) / a
				percent=round(percent,2)

			investment_start=units*buy_price
			investment_now=units*market_price	
		
			investment_now=float(investment_now)
			investment_now=round(investment_now,8)
			
			#Stoploss Stuff
			#
			#original_stoploss_percent=r.hget(redis_key,'stoploss_percent').decode('utf-8')
			#original_stoploss_price_ded=buy_price/100*float(original_stoploss_percent)
			#original_stoploss_price=float(buy_price-original_stoploss_price_ded)
			#original_stoploss_price=round(original_stoploss_price,8)
			#key=str(symbol)+'-ORIGINAL-STOPLOSS-PRICE'
			#mc.set(key,original_stoploss_price,86400)
			
			key=str(symbol)+'-ORIGINAL-STOPLOSS-PRICE'	
			if(mc.get(key)):
				original_stoploss_price=float(mc.get(key))
			else:
				if mc.get(key):
					last_stoploss=mc.get(key)		
				
			message=":::BOT " +str(symbol)+"\nSTARTED: "+str(running)+str("\nBUY PRICE: ")+str(buy_price)+"\nPRICE NOW: "+str(market_price)+"\nUNITS: "+str(units)
			message=message+"\nVALUE START "+'('+str(trade_to)+'): '+str(investment_start)
			message=message+"\nVALUE NOW "+'('+str(trade_to)+'): '+str(investment_now)
			message=message+"\nP&L: "+str(profit_total)+' ('+str(percent)+'%)'
			message=message+"\nBOT ID: "+str(bot_id)
	
			message_tg="<b>:::BOT " +str(symbol)+"</b>\n<b>STARTED:</b> "+str(running)+str("\n<b>BUY PRICE:</b> ")+str(buy_price)+"\n<b>PRICE NOW:</b> "+str(market_price)+"\n<b>UNITS:</b> "+str(units)
			message_tg=message_tg+"\n<b>VALUE START "+'('+str(trade_to)+'):</b> '+str(investment_start)
			message_tg=message_tg+"\n<b>VALUE NOW "+'('+str(trade_to)+'):</b> '+str(investment_now)
			message_tg=message_tg+"\n<b>P&L:</b> "+str(profit_total)+' ('+str(percent)+'%)'
			message_tg=message_tg+"\n<b>BOT ID:</b> "+str(bot_id)
	
			key=str(symbol)+'-SYSTEM-STOPLOSS'
			
			if mc.get(key):
				last_stoploss=mc.get(key)		
			else:
				last_stoploss=int(0)
				
			new_stoploss=float(nickbot.wall_magic(symbol,last_stoploss))
			print("NEW SL ADD: "+str(new_stoploss))
			print(new_stoploss)
							
			print("FUCKINGDB NSL: "+str(symbol)+" "+str(new_stoploss))
			print("FUCKINGDB LSL: "+str(symbol)+" "+str(last_stoploss))	
			if new_stoploss>last_stoploss:
			
				rkt=symbol+"TTT"
				sl_pos=int(r.get(rkt))
				r.hset(redis_key, 'book_pos',sl_pos)

				ikey=str(bot_id)+'-GOALPOSTS'
				cycles=r.incr(ikey)
					
				gkey=str(bot_id)+'-GOALPOST-STOPLOSS'
				r.set(gkey,new_stoploss)				
	
				print(str(symbol)+":::STOPLOSS/MOVER MOVED GOAL POST: "+str(cycles)+" Times!\n")
				
				print("Goal Post Move Set :"+str(key)+" Stoploss to "+str(new_stoploss))
				
				key=str(symbol)+'-SYSTEM-STOPLOSS'
				mc.set(key,new_stoploss,86400)	
					
				ckey=str(bot_id)+'-CPS'
				r.hincrby(ckey, 'checkpoints',1)
				r.hset(ckey, 'checkpoint_stoploss',new_stoploss)

				ckey=str(bot_id)+'-CPS'
				if r.hget(ckey,"checkpoints"):
					checkpoints=int(r.hget(ckey, 'checkpoints').decode('utf-8'))
					message=message+"\nLAST CHECKPOINT: "+str(new_stoploss)
					message=message+"\nCHECKPOINTS: "+str(checkpoints)
			
					message_tg=message_tg+"\n<b>LAST CHECKPOINT:</b> "+str(new_stoploss)
					message_tg=message_tg+"\n<b>CHECKPOINTS:</b> "+str(checkpoints)
		
					bkey=str(symbol)+'-UPDATE'
					r.setex(bkey,1,"N")
					time.sleep(1)

					print("Db Deleting: "+str(bkey))
					r.set(bkey,message_tg)		

					print(message_tg)
					
			elif last_stoploss==0:
				print("First Time Set :"+str(key)+" Stoploss to "+str(original_stoploss_price))
				key=str(symbol)+'-SYSTEM-STOPLOSS'
				mc.set(key,original_stoploss_price,864000)	

				ckey=str(bot_id)+'-CPS'
				if r.hget(ckey,"checkpoints"):
		
					checkpoint_stoploss=float(r.hget(ckey, 'checkpoint_stoploss').decode('utf-8'))
					checkpoints=int(r.hget(ckey, 'checkpoints').decode('utf-8'))
					message=message+"\nLAST CHECKPOINT: "+str(checkpoint_stoploss)
					message=message+"\nCHECKPOINTS: "+str(checkpoints)
			
					message_tg=message_tg+"\n<b>LAST CHECKPOINT:</b> "+str(checkpoint_stoploss)
					message_tg=message_tg+"\n<b>CHECKPOINTS:</b> "+str(checkpoints)
		
					bkey=str(symbol)+'-UPDATE'
					r.setex(key,1,bkey)
					time.sleep(1)

					print("Db Deleting: "+str(bkey))
					r.set(bkey,message_tg)		

					print(message_tg)
			print(str(symbol)+":::END !!!!!!!!!!!!!\n\n")
while True:
	#try:
	loop_bots()
	print("STOPLOSS UPDATER")
	#except:
	#	print("")
	time.sleep(5)		


		import os
from collections import OrderedDict
import requests
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import talib
import numpy as np
import ccxt
import redis
import datetime
import configparser
import subprocess
import time
import shlex
import argparse
import heapq
import nickbot

config = configparser.ConfigParser()
config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database='cmc'
telegram_id=config['binance']['TEEGRAM_ID_EMBED']

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')
	
r = redis.Redis(host='localhost', port=6379, db=0)

mc = memcache.Client(['127.0.0.1:11211'], debug=0)

#conn = redis.Redis('127.0.0.1')

#Name of bot PyCryptoBot

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
#print(telegram_id)
updater = Updater(token=telegram_id)

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
		
def query_ath(name):

	try:
		db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,'cmc')
		cursor = db.cursor()
		sql = """SELECT ath_date,price from aths where coin=%s"""
		cursor.execute(sql,(name))
		for row in cursor:
			ath_date=row[0]	
			ath_price=row[1]
			ath_price='${:,.2f}'.format(ath_price)
			ret="\n"+str(name)+("\nAth Date: "+str(ath_date)+ "\n"+ str(name)+" Ath Price: "+str(ath_price))
			db.close()
		return(ret)
	except:
		print("some error")

def market_health():
	try:
		url = 'https://api.coinmarketcap.com/v2/ticker/'
		r=requests.get(url)
		res = (r.content.strip())
		status = r.status_code
		data = json.loads(res.decode('utf-8'))
	
		plus_1h=int(0)
		plus_24h=int(0)
		plus_7d=int(0)
	
		rows=data['data']
		for row in rows:
			row_data=rows[row]["quotes"]["USD"]
			p_1h=row_data['percent_change_1h']
			p_24h=row_data["percent_change_24h"]
			p_7d=row_data["percent_change_7d"]
		
			if p_1h:
				if p_1h > 0:
					plus_1h += 1
		
			if p_24h:
				if p_24h > 0:
					plus_24h += 1
			if p_7d:
				if p_7d > 0:
					plus_7d += 1
		
		minus_1h = int(100) - plus_1h
		minus_24h = int(100) - plus_24h
		minus_7d = int(100) - plus_7d

		ret=("Market Health For Top 100\n1 Hr Green: "+str(plus_1h)+"% Red: "+str(minus_1h)+ "%\n24 Hr Green: "+str(plus_24h)+"% Red: "+str(minus_24h)+ "%\n7 Day Green: "+str(plus_7d)+"% Red: "+str(minus_7d)+ "%") 
	except:
		print("some error")
	return(ret)
	

def memcache_stuff():
#Connect to memcache
	mc = memcache.Client(['127.0.0.1:11211'], debug=0)

	if mc.get("some_key2"):
		print("some key exists")
	
		#mc.set("some_key", "Some value")
		#value = mc.get("some_key")
		#mc.delete("another_key")
		#mc.incr("key")
		#mc.decr("key")
		#print(value)


def get_global():
	url ='https://api.coinmarketcap.com/v1/global/'
	r=requests.get(url)

	res = (r.content.strip())

	status = r.status_code

	data = json.loads(res.decode('utf-8'))

	market_cap			= int(data['total_market_cap_usd'])
	volume_24			= data['total_24h_volume_usd']
	btc_per				= str(data['bitcoin_percentage_of_market_cap'])
	total_currencies	= str(data['active_currencies'])
	total_assets		= str(data['active_assets'])
	active_markets		= str(data['active_markets'])
	
	market_cap='${:,.2f}'.format(market_cap)
	volume_24='${:,.2f}'.format(volume_24)

	health=market_health()
	if not health:
		health=""

	
	ret="Market Cap:\t"+str(market_cap)+"\n24 Hours:\t"+str(volume_24)+"\nBTC Dominance:\t"+btc_per+"%\nCurrencies: "+total_currencies+"\tAssets:\t"+active_markets+"\tMarkets: "+active_markets+"\n\n"+str(health)
	return ret;	

def get_ticker(ucoin):
	ucoin = ucoin.lower()
	url = 'https://api.coinmarketcap.com/v1/ticker/?limit=10000'
	r=requests.get(url)

	res = (r.content.strip())

	status = r.status_code

	data = json.loads(res.decode('utf-8'))

	coin_data = []
	#print(data)
	for row in data:
		
			coin_n=row['name']
			coin		= str(row['name'].lower())
			ticker		= str(row['symbol'].lower())
			
			if ticker==ucoin:
				rank 		= int(row['rank'])
				price_usd	= row['price_usd']
				price_btc	= float(row['price_btc'])
				market_cap	= float(row['market_cap_usd'])
				total_supply= float(row['total_supply'])
				change_1h	= row['percent_change_1h']
				change_24h	= row['percent_change_24h']
				change_7d	= row['percent_change_7d']
				circulating = float(row['available_supply'])

				market_cap='${:,.2f}'.format(market_cap)
				total_supply='{:,.2f}'.format(total_supply)
				price_btc='{:,.8f}'.format(price_btc)
				circulating='{:,.8f}'.format(circulating)

				ath=query_ath(coin_n)
				if not ath:
					ath=""
				else:
					print(ath)

				ret=str(ticker.upper()) +" #"+str(rank)+"\nPrice: $"+str(price_usd)+" BTC: "+str(price_btc)+"\n1hr ("+change_1h+ "%) 24hr("	+change_24h+ "%) 7D("	+change_7d+ "%)""\nMarket Cap "+str(market_cap)+ "\nMax Supply: "+str(total_supply)+"\nCirculating Supply: "+str(circulating+str(ath))

				
	if ret=='':
		return("not found")
	else:
		return(ret)

def start(bot, update):
	help="<b>I am T1000, i can do the following commands:</b>\n\n"
	help=help+"/market to get global market data, and market health!\n"
	help=help+"/ticker SYMBOL to get coin Ticker and ATH\n"
	help=help+"/alerts #seconds to see alerts for last x seconds on pumps"
	help=help+"/walls SYMBOL to see resistance / support levels or walls"
	bot.send_message(chat_id=update.message.chat_id, text=help,parse_mode= 'HTML')
	
def help(bot, update):
	help="<b>I am T1000, i can do the following commands:</b>\n\n"
	help=help+"/market to get global market data, and market health!\n"
	help=help+"/ticker SYMBOL to get coin Ticker and ATH\n"
	help=help+"/alerts #seconds to see alerts for last x seconds on pumps\n"
	help=help+"/walls SYMBOL to see resistance / support levels or walls,parse_mode= 'HTML'"

	bot.send_message(chat_id=update.message.chat_id, text=help,parse_mode= 'HTML')

def ticker(bot, update, args):
	coin=args[0]
	data=get_ticker(coin)
	bot.send_message(chat_id=update.message.chat_id, text=data)
	
def market(bot, update):
	data=get_global()
	bot.send_message(chat_id=update.message.chat_id, text=data)
	
def news(bot, update):
	data=read_news()
	bot.send_message(chat_id=update.message.chat_id, text=data)

def fetch_order_book(exchange,symbol,type,qlimit):
	#limit = 1000
	ret=exchange.fetch_l2_order_book(symbol, qlimit)

	if type=='bids':
		bids=ret['bids']
		return bids
	else:
		asks=ret['asks']
		return asks

def sell2(bot, update,args):	
	bid=update.message.from_user.id

	symbol=args[0].upper()
	
	exchange=nickbot.get_exchange()

	bid=update.message.from_user.id
	price=nickbot.get_price(exchange,symbol)
	
	ret=exchange.fetch_closed_orders (symbol, 1);
	if ret:
		data=ret[-1]['info']
		side=data['side']
		units=float(data['executedQty'])

		last_price=float(data['price'])
		
		profit=price-last_price
		profit=profit*units
		prices = [last_price,price]
		for a, b in zip(prices[::1], prices[1::1]):
			percent=100 * (b - a) / a

		percent=round(percent,2)
		profit=round(profit,2)

		mc = memcache.Client(['127.0.0.1:11211'], debug=0)
		key=str(symbol)+'-PAUSED'	

		mc.set(key,1,86400)			

		message=str(symbol)+"Selling Now!!! Price: "+str(price)+" Last Price: "+str(last_price)+" Units: "+str(units)+" Profit: "+str(profit)+' ('+str(percent)+'%)'

		ret=exchange.create_order (symbol, 'limit', 'sell', units, price)
		order_id=int(ret['info']['orderId'])
		log_order(bot_id,order_id,'SELL',symbol,rsi_symbol,trade_from,trade_to,price,units)
					
		bot.send_message(chat_id=update.message.chat_id, text=message)

def fetch_last_order(exchange,symbol):
	ret=exchange.fetch_closed_orders (symbol, 1);
	print(ret)
	if ret:
		data=ret[-1]['info']
		side=data['side']
		price=float(data['price'])
		return data
	else:
		print("returning: 0")
		data=0
		return data


def untether(bot, update, args):
	exchange=nickbot.get_exchange()
	symbol=str(args[0]).upper()
	if args[1]:
		stablecoin=str(args[1]).upper()
	else:
		stablecoin='USDT'
	balances=exchange.fetch_balance ()
	balance=float(format(balances[symbol]['total'],'.8f'))
	print(str(balance))
	
	pair=str(symbol)+"/"+str(stablecoin)	
					
	last_array=nickbot.fetch_last_order(exchange,pair)
	last_price=float(last_array['price'])
	last_type=last_array['type']
	last_units=last_array['executedQty']

	units=float(last_units)
	book=nickbot.fetch_order_book(exchange,pair,'bids',100)
	buy_price=float(book[0][0])
	total_amount=round(buy_price*units,2)
	message="UNTETHERING/BUYING BACK: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(buy_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)
	print(message)
	bot.send_message(chat_id=update.message.chat_id, text=message, parse_mode= 'HTML')
	exchange=nickbot.get_exchange()
	ret=exchange.create_order (pair, 'limit', 'buy', units, buy_price)

def panic(bot, update, args):
	exchange=nickbot.get_exchange()
		
	symbol='BTC'
	stablecoin='USDT'
	balance=float(format(balances[symbol]['total'],'.8f'))
	pair=str(symbol)+"/"+str(stablecoin)	
					
	book=nickbot.fetch_order_book(exchange,pair,'bids',100)
	sell_price=float(book[0][0])
	
	message="UNTETHERING/BUYING BACK: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(buy_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)
	print(message)
	bot.send_message(chat_id=update.message.chat_id, text=message, parse_mode= 'HTML')
	exchange=nickbot.get_exchange()
	ret=exchange.create_order (pair, 'limit', 'buy', units, buy_price)

def tether(bot, update, args):
	exchange=nickbot.get_exchange()
	symbol=str(args[0]).upper()
	if args[1]:
		stablecoin=str(args[1]).upper()
	else:
		stablecoin=str('USDT')
	percent=str(args[2])
		
	balances=exchange.fetch_balance ()
	balance=float(format(balances[symbol]['total'],'.8f'))
	print(str(balance))
	units=units=balance/100*float(percent)
	units=round(units,2)
	pair=str(symbol)+"/"+str(stablecoin)
	print("FDEBYG:")
	book=nickbot.fetch_order_book(exchange,pair,'bids',100)
	sell_price=float(book[0][0])
	total_amount=round(sell_price*units,2)
	message="TETHERING: "+str(symbol)+" UNITS: "+str(units)+" PRICE: "+str(sell_price)+" TO STABLE COIN: "+str(stablecoin)+" TOTAL USD: "+str(total_amount)
	print(message)
	bot.send_message(chat_id=update.message.chat_id, text=message, parse_mode= 'HTML')
	exchange=nickbot.get_exchange()
	ret=exchange.create_order (pair, 'limit', 'sell', units, sell_price)
				
def cashout(bot, update, args):
	
	id=args[0]
	bot_id=int(id)
	revkey='REVERSE-'+str(id)
	symbol=r.get(revkey).decode('utf-8')			
	exchange=nickbot.get_exchange()
	t_key="TTT-"+str(symbol)
	if mc.get(t_key):
		buy_array=mc.get(t_key)
	else:
		#Cache last order in ram for 60 seconds to speed up api calls
		buy_array=fetch_last_order(exchange,symbol)
		mc.set(t_key,buy_array,300)

	units=float(buy_array['executedQty'])

	book=nickbot.fetch_order_book(exchange,symbol,'bids',1)
	sell_price=float(book[0][0])
	
	#Execute Sell Order
	ret=exchange.create_order (symbol, 'limit', 'market', units)
	order_id=int(ret['info']['orderId'])
	log_order(bot_id,order_id,'SELL',symbol,rsi_symbol,trade_from,trade_to,sell_price,units)
					
	bot_name=symbol
	r.srem("botlist", bot_name)
	r.delete(bot_name)
	r.sadd("botlist-stopped", bot_name)
	config = configparser.ConfigParser()
	config_file='/home/crypto/cryptologic/pid-configs/init.ini'
	config.read(config_file)
	
	bot_section='watcher:'+str(bot_name)
	config.remove_section(bot_section)
	
	with open(config_file, 'w+') as configfile:
		config.write(configfile)
		print("Write Config File to: "+str(config_file))
		print("Wrote: "+str(configfile))
		key=str(symbol)+'-SYSTEM-STOPLOSS'
		mc.delete(key)

	message="<b>Cashed Out "+str(units)+" Of: "+str(symbol)+" At: "+str(sell_price)+"</b>"

	bot.send_message(chat_id=update.message.chat_id, text=message, parse_mode= 'HTML')


def delete_bot(bot, update, args):
	
	bot_name=args[0].upper()
	symbol=bot_name
	print(bot_name)
	
	ret="::Crypto Logic Deleted bot: "+str(bot_name)
	r.srem("botlist", bot_name)
	r.delete(bot_name)
	r.sadd("botlist-stopped", bot_name)
	config = configparser.ConfigParser()
	config_file='/home/crypto/cryptologic/pid-configs/init.ini'
	config.read(config_file)
	
	bot_section='watcher:'+str(bot_name)
	config.remove_section(bot_section)
	
	with open(config_file, 'w+') as configfile:
		config.write(configfile)
		print("Write Config File to: "+str(config_file))
		print("Wrote: "+str(configfile))
	
		#subprocess.run(["/usr/bin/circusd", "--daemon",config_file])
			
		key=str(symbol)+'-SYSTEM-STOPLOSS'
		if mc.get(key):
			mc.delete(key)

		bot.send_message(chat_id=update.message.chat_id, text=ret)
		
		#subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def spawn_bot(symbol):
	
	config = configparser.ConfigParser()
	
	bfn=str(symbol.lower())+'.ini'
	bfn=bfn.replace("/", "-")
	
	bot_name='watcher:'+str(symbol)
	bot_file='/home/crypto/cryptologic/pid-configs/init.ini'
	args='--trading_pair '+str(symbol)

	#If we allready have this bot in the circus ini don't add it again
	config.read(bot_file)

	if not config.has_section(bot_name):
	
		config.add_section(bot_name)
		config.set(bot_name, 'cmd', '/usr/bin/python3.6 /home/crypto/cryptologic/bots/autotrader.py')
		config.set(bot_name, 'args', args)
		config.set(bot_name, 'warmup_delay', '0')
		config.set(bot_name, 'numprocesses', '1')

		with open(bot_file, 'w') as configfile:
			configfile.write("\n")
			config.write(configfile)
			print("Write Config File to: "+str(bot_file))
			print("Wrote: "+str(configfile))

		subprocess.run(["/usr/bin/circusctl", "reloadconfig"])

def add_bot(bot, update, args):

	r = redis.Redis(host='localhost', port=6379, db=0)
	
	var1=args[0]
	
	if var1=="confirm":
	
		redis_key="bconfig-tmp"
		all=r.hgetall(redis_key)
		
		trading_on=r.hget(redis_key,"trading_on")
		trading_on=trading_on.decode('utf-8')
		rsi_symbol=r.hget(redis_key,"rsi_symbol")
		rsi_symbol=rsi_symbol.decode('utf-8')
		symbol=r.hget(redis_key,"symbol")
		symbol=symbol.decode('utf-8')
		units=r.hget(redis_key,"units")
		units=units.decode('utf-8')
		trade_from=r.hget(redis_key,"trade_from")
		trade_from=trade_from.decode('utf-8')
		trade_to=r.hget(redis_key,"trade_to")
		trade_to=trade_to.decode('utf-8')
		buy_pos=r.hget(redis_key,"buy_pos")
		buy_pos=buy_pos.decode('utf-8')
		sell_pos=r.hget(redis_key,"sell_pos")
		sell_pos=sell_pos.decode('utf-8')
		stoploss_percent=r.hget(redis_key,"stoploss_percent")
		stoploss_percent=stoploss_percent.decode('utf-8')
		safeguard_percent=r.hget(redis_key,"safeguard_percent")
		safeguard_percent=safeguard_percent.decode('utf-8')
		use_stoploss=r.hget(redis_key,"use_stoploss")
		use_stoploss=use_stoploss.decode('utf-8')
		candle_size=r.hget(redis_key,"candle_size")
		candle_size=candle_size.decode('utf-8')
		rsi_buy=r.hget(redis_key,"rsi_buy")
		rsi_buy=rsi_buy.decode('utf-8')
		rsi_sell=r.hget(redis_key,"rsi_sell")
		rsi_sell=rsi_sell.decode('utf-8')
		live=r.hget(redis_key,"live")
		live=live.decode('utf-8')
		instant_market_buy=r.hget(redis_key,"instant_market_buy")
		instant_market_buy=instant_market_buy.decode('utf-8')
		enable_buybacks=r.hget(redis_key,"enable_buybacks")
		enable_buybacks=enable_buybacks.decode('utf-8')
		enable_safeguard=r.hget(redis_key,"enable_safeguard")
		enable_safeguard=enable_safeguard.decode('utf-8')
		force_buy=r.hget(redis_key,"force_buy")
		force_buy=force_buy.decode('utf-8')
		force_sell=r.hget(redis_key,"force_sell")
		force_sell=force_sell.decode('utf-8')
	
		bot_name=symbol
		
		r.sadd("botlist", bot_name)
		timestamp=time.time()

		r.set(symbol,timestamp)
		running=datetime.datetime.fromtimestamp(timestamp).strftime("%A, %B %d, %Y %I:%M:%S")

		timestamp=time.time()
		ts_raw=timestamp
		running=datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
			
		redis_key="bconfig-"+symbol
		
		r.hmset(redis_key, all)
		ret="::Crypto Logic new bot: "+str(symbol)+" has been spawned on - "+str(running)
		ret=ret+"\n\n::Exchange: "+trading_on
		ret=ret+"\n::Trade Pair: "+str(symbol)
		ret=ret+"\n::Units: "+str(units)
		ret=ret+"\n::Buy Book Scrape Position: "+str(buy_pos)
		ret=ret+"\n::Sell Book Scrape Position: "+str(sell_pos)
		ret=ret+"\n::RSI Buy: "+str(rsi_buy)
		ret=ret+"\n::RSI Sell: "+str(rsi_sell)
		ret=ret+"\n::Stoploss Percent: "+str(stoploss_percent)
		ret=ret+"\n::Safeguard Percent: "+str(safeguard_percent)
		ret=ret+"\n::Candle Size: "+candle_size
		ret=ret+"\n::Stoploss Enabled: "+str(use_stoploss)
		ret=ret+"\n::Live Trading Enabled: "+live
		ret=ret+"\n::TA Candle Size: "+candle_size
		ret=ret+"\n::Instant Market Buy: "+str(instant_market_buy)
		ret=ret+"\n::Enable Buy Backs After Stoploss Hit: "+str(enable_buybacks)

		ret=ret+"\n\nIf you ever want to kill it issue /deletebot "+str(symbol)

		bid=r.incr("bids")
		r.hset(redis_key,"id",bid)

		if force_buy=="yes":
			mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
			key=symbol+"-FORCE-BUY"
			mc.set(key,force_buy,86400)			

		elif force_sell=="yes":
			mc = memcache.Client(['127.0.0.1:11211'], debug=0)	
			key=symbol+"-FORCE-SELL"
			mc.set(key,force_sell,86400)			

		if instant_market_buy=="yes":
			print("")	
			exchange=nickbot.get_exchange()

			buy_book=nickbot.fetch_order_book(exchange,symbol,'bids','1000')
			buy_pos=int(buy_pos)
			buy_price=float(buy_book[buy_pos][0])

			print("ALERT ALERT ALERT: BPPPP"+str(buy_price))
			print(buy_price)
			ret=exchange.create_order (symbol, 'limit', 'buy', units, buy_price)
			order_id=int(ret['info']['orderId'])
			log_order(bot_id,order_id,'BUY',symbol,rsi_symbol,trade_from,trade_to,buy_price,units)		
		spawn_bot(symbol)
		bot.send_message(chat_id=update.message.chat_id, text=ret)	

	else:
		argstr=' '.join(args[0:])
		print(argstr)
		parser = argparse.ArgumentParser()
				
		parser.add_argument('--trading_on', help='Exchange name i.e binance')
		parser.add_argument('--rsi_symbol', help='RSI SYMBOL pair i.e IOTAUSDT')
		parser.add_argument('--trading_pair', help='Trading pair i.e BTC/USDT')
		parser.add_argument('--units', help='Number of coins to trade')
		parser.add_argument('--trade_from', help='I.E BTC')
		parser.add_argument('--trade_to', help='I.E USDT')
		parser.add_argument('--buy_pos', help='Buy book position to clone')
		parser.add_argument('--sell_pos', help='Sell book position to clone')
		parser.add_argument('--use_stoploss', help='1 to enable, 0 to disable')
		parser.add_argument('--candle_size', help='i.e 5m for 5 minutes')
		parser.add_argument('--enable_safeguard', help='If enabled it will never buy back more expensive than last sell')
		parser.add_argument('--safeguard_percent', help='safeguard percent if buying back cheaper')
		parser.add_argument('--stoploss_percent', help='stoploss percent')
		parser.add_argument('--rsi_buy', help='Rsi Number under to trigger a buy, i.e 20')
		parser.add_argument('--rsi_sell', help='Rsi Number over to trigger a sell, i.e 80')
		parser.add_argument('--live', help='1 for Live trading, 0 for dry testing.')
		parser.add_argument('--instant_market_buy', help='To make the first buy instant @ market price')
		parser.add_argument('--enable_buybacks', help='If enabled will buy back cheaper after a stoploss sell')
		parser.add_argument('--force_buy', help='If enabled will force a buy on the first trade, only needed really for an rsi buy where u already hold units')
		parser.add_argument('--force_sell', help='If enabled will force a sell on the first trade, only needed really for an rsi sell where u already hold units')

		pargs = parser.parse_args(shlex.split(argstr))

		trading_on=str(pargs.trading_on)
		rsi_symbol=str(pargs.rsi_symbol)
		trading_pair=str(pargs.trading_pair)
		units=float(pargs.units)
		trade_from=str(pargs.trade_from)
		trade_to=str(pargs.trade_to)
		buy_pos=int(pargs.buy_pos)
		sell_pos=int(pargs.sell_pos)
		stoploss_percent=float(pargs.stoploss_percent)
		use_stoploss=str(pargs.use_stoploss)
		candle_size=str(pargs.candle_size)
		safeguard_percent=float(pargs.safeguard_percent)
		rsi_buy=float(pargs.rsi_buy)
		rsi_sell=float(pargs.rsi_sell)
		live=str(pargs.live)
		bot_name=str(trading_pair)
		instant_market_buy=str(pargs.instant_market_buy)
		enable_buybacks=str(pargs.enable_buybacks)
		enable_safeguard=str(pargs.enable_safeguard)
		force_buy=str(pargs.force_buy)
		force_sell=str(pargs.force_sell)

		symbol=bot_name
		if r.sismember("botlist", trading_pair):
			ts=float(r.get(bot_name).decode('utf-8'))
			print(ts)
			running=datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %I:%M:%S")

			txt="we allready have a bot running called: "+str(bot_name)+" Its been Running since: "+str(running)
			bot.send_message(chat_id=update.message.chat_id, text=txt)	
		else:	
			ret="::Crypto Logic Please review the settings for new bot: "+str(symbol)
			ret=ret+"\n\n::Exchange: "+trading_on
			ret=ret+"\n::Trade Pair: "+str(symbol)
			ret=ret+"\n::Units: "+str(units)
			ret=ret+"\n::Buy Book Scrape Position: "+str(buy_pos)
			ret=ret+"\n::Sell Book Scrape Position: "+str(sell_pos)
			ret=ret+"\n::RSI Buy: "+str(rsi_buy)
			ret=ret+"\n::RSI Sell: "+str(rsi_sell)
			ret=ret+"\n::Stoploss Percent: "+str(stoploss_percent)
			ret=ret+"\n::Safeguard Percent: "+str(safeguard_percent)
			ret=ret+"\n::Candle Size: "+candle_size
			ret=ret+"\n::Stoploss Enabled: "+str(use_stoploss)
			ret=ret+"\n::Live Trading Enabled: "+live
			ret=ret+"\n::Instant Market Buy: "+str(instant_market_buy)
			ret=ret+"\n::TA Candle Size: "+candle_size
			ret=ret+"\n::Enable Buybacks: "+str(enable_buybacks)
			ret=ret+"\n::Enable Safeguard: "+str(enable_safeguard)
			ret=ret+"\n::Force Buy: "+str(force_buy)
			ret=ret+"\n::Force Sell: "+str(force_sell)

			ret=ret+"\n\nIf you have reviewed all settings carefully reply with /addbot confirm to execute!"

			bot_config = {"trading_on":str(trading_on),
			"rsi_symbol":str(rsi_symbol), 
			"symbol":str(bot_name), 
			"units":float(units), 
			"trade_from":str(trade_from), 
			"trade_to":str(trade_to), 
			"buy_pos":int(buy_pos),
			"sell_pos":int(sell_pos),
			"stoploss_percent":float(stoploss_percent),
			"use_stoploss":use_stoploss,
			"candle_size":str(candle_size),
			"safeguard_percent":float(safeguard_percent),
			"rsi_buy":float(rsi_buy),
			"rsi_sell":float(rsi_sell),
			"instant_market_buy":str(instant_market_buy),
			"enable_buybacks":str(enable_buybacks),
			"enable_safeguard":str(enable_safeguard),
			"force_buy":str(force_buy),
			"force_sell":str(force_sell),
			"live":str(live)}
			
			print(bot_config)
			ksymbol=str(symbol)

			redis_key="bconfig-tmp"
			r.hmset(redis_key, bot_config)
			bot.send_message(chat_id=update.message.chat_id, text=ret)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail


def bookintel(bot, update, args):
	
	symbol=args[0].upper()
	book=args[1]
	start_price=float(args[2])
	end_price=float(args[3])
	
	exchange=nickbot.get_exchange()
	
	p=0
	total_volume=0
	if book=="buy":
		bids=nickbot.fetch_order_book(exchange,symbol,'bids','1000')
		p=1
	elif book=="sell":
		bids=nickbot.fetch_order_book(exchange,symbol,'asks','500')	
		p=1
	print(bids)
	if p==1:
		for k,v in bids:
			if k>=start_price and k<=end_price:
				total_volume+=v
			
		ret="<b>:::VOLUME INTEL FOR "+str(symbol).upper()+" BOOK - "+str(book)+" </b>\n"
		ret=ret+"<b>:::PRICE BETWEEN: "+str(start_price)+" AND: "+str(end_price)+"</b>\n"
		ret=ret+"<b>:::RESULT IS: "+str(total_volume)+"</b>\n"	
		bot.send_message(chat_id=update.message.chat_id, text=ret,parse_mode= 'HTML')
		

def walls(bot, update, args):
	
	symbol=args[0].upper()
	exchange=nickbot.get_exchange()
	buy_book=nickbot.fetch_order_book(exchange,symbol,'bids','500')
	sell_book=nickbot.fetch_order_book(exchange,symbol,'asks','500')

	buy_dic={}
	sell_dic={}
	
	for k,v in buy_book:
		buy_dic[k]=v
		print("Key: "+str(k)+" v: "+str(v))

	for k,v in sell_book:
		sell_dic[k]=v
				
	buy_walls=heapq.nlargest(25, buy_dic.items(), key=itemgetter(1))
	sell_walls=heapq.nlargest(25, sell_dic.items(), key=itemgetter(1))
	
	message="<b>WALL INTEL:</b>\n\n"
	
	message=message+"<b>BUY WALLS ('SUPPORT')</b>\n"
	
	for k,v in sorted(buy_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"

	message=message+"\n<b>SELL WALLS ('RESISTANCE')</b>'\n"
	for k,v in sorted(sell_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"
		
	bot.send_message(chat_id=update.message.chat_id, text=message,parse_mode= 'HTML')

def alerts(bot,update,args):
	
	first_price=0
	
	secs=int(args[0])

	if len(args)>1:
		pcoin=str(args[1].upper())
	else:
		pcoin=0
		
	ts_now = datetime.datetime.now()
	ts_now_ts=float(time.mktime(ts_now.timetuple())	)
	ts_now_human=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")

	
	print("TSN: ")
	print(ts_now_ts)
	print(ts_now_human)

	timestamp=ts_now
	ts_from = ts_now - datetime.timedelta(seconds=secs)
	ts_from_ts=float(time.mktime(ts_from.timetuple()))
	ts_from_human=datetime.datetime.fromtimestamp(ts_from_ts).strftime("%Y-%m-%d %H:%M:%S")
	
	print("TSF: ")
	print(ts_from_ts)
	print(ts_from_human)

	r = redis.Redis(host='localhost', port=6379, db=0)
	
	date_time=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d %H:%M:%S")
	date_today=datetime.datetime.fromtimestamp(ts_now_ts).strftime("%Y-%m-%d")

	pump_key=str(date_today+"-ALERTLIST")
	pump_coins=r.smembers(pump_key)

	exchange=nickbot.get_exchange()
	
	for coin in pump_coins:
		coin=coin.decode('utf-8')
			
		print("T800 DB: "+str(coin))
		coin_ids=r.smembers(coin+'-IDS')
		coin_ids=sorted(coin_ids)
		message="<b>:: Alerts For: "+str(coin)+str('</b>')
		c=0
		last_change=0

		seen=0

		for cid in coin_ids:
			cid=cid.decode('utf-8')
			rkey=str(coin)+'-'+str(cid)
			coin_hash=r.hgetall(rkey)
			if coin_hash:
				symbol=r.hget(rkey,"symbol").decode('utf-8')
				ticker_symbol=symbol.upper()

				if symbol.endswith('BTC'):
					ticker_symbol = replace_last(ticker_symbol, 'BTC', '')
					ticker_symbol=ticker_symbol+'/BTC'
				elif symbol.endswith('USDT'):
					ticker_symbol=symbol
					ticker_symbol = replace_last(ticker_symbol, 'USDT', '')
					ticker_symbol=ticker_symbol+'/USDT'
				elif symbol.endswith('BNB'):
					ticker_symbol = replace_last(ticker_symbol, 'BNB', '')
					ticker_symbol=ticker_symbol+'/BNB'
				elif symbol.endswith('TUSD'):
					ticker_symbol = replace_last(ticker_symbol, 'TUSD', '')
					ticker_symbol=ticker_symbol+'/TUSD'	
				elif symbol.endswith('USD'):
					ticker_symbol = replace_last(ticker_symbol, 'USD', '')
					ticker_symbol=ticker_symbol+'/USD'
				elif symbol.endswith('USDC'):
					ticker_symbol = replace_last(ticker_symbol, 'USDC', '')
					ticker_symbol=ticker_symbol+'/USDC'
				elif symbol.endswith('PAX'):
					ticker_symbol = replace_last(ticker_symbol, 'PAX', '')
					ticker_symbol=ticker_symbol+'/PAX'	
				elif symbol.endswith('USDS'):
					ticker_symbol = replace_last(ticker_symbol, 'USDS', '')
					ticker_symbol=ticker_symbol+'/USDS'	
				elif symbol.endswith('ETH'):
					ticker_symbol = replace_last(ticker_symbol, 'ETH', '')
					ticker_symbol=ticker_symbol+'/ETH'	
				if pcoin and ticker_symbol!=pcoin:
					#print(pcoin_nb)
					#print(ticker_symbol)
					continue
				else:
					print("Got it")
				cidn=float(cid)
	
				msorted={}
			
				if cidn>=ts_from_ts:
					date_time=r.hget(rkey,"date_time").decode('utf-8')
					price=float(r.hget(rkey,"price").decode('utf-8'))
					percent=r.hget(rkey,"percent").decode('utf-8')
					spread=r.hget(rkey,"spread").decode('utf-8')
					high=r.hget(rkey,"high").decode('utf-8')
					low=r.hget(rkey,"low").decode('utf-8')
					btc_price=r.hget(rkey,"btc_price").decode('utf-8')
					btc_price="{0:.8}".format(btc_price)
									
					if percent!=last_change or last_change==0:			
						if seen==0:
							first_price=price
							first_price=str(format(price, '.6f'))
							seen=1
						if 'e' in str(price):
							price=str(format(price, '.6f'))
						else:
							price=format(price, '.6f')
						if float(percent)>float(last_change):
							message=message+"\n\n<b>"+str(date_time)+"\tPrice: "+str(price)+' Change %:'+str(percent)+" Spread: "+str(spread)+'</b>'
						else:
							message=message+"\n\n<i>"+str(date_time)+"\tPrice: "+str(price)+' Change %:'+str(percent)+" Spread: "+str(spread)+'</i>'
						c+=1
					last_change=percent							
				
		if c>0:
			print(symbol)
			print(ticker_symbol)
			ticker = exchange.fetch_ticker(ticker_symbol.upper())
			tick=0
			if ticker:
				bid=float(ticker['bid'])
				last=float(ticker['last'])
				ask=float(ticker['ask'])
				open=float(ticker['open'])
				close=float(ticker['close'])
				high=float(ticker['high'])
				low=float(ticker['low'])
				tick=1
				first_price=float(first_price)
				
				if first_price>0.0 and tick==1:
					price_diff=last-first_price
					prices = [first_price,last]
				
					price_diff=str(format(price_diff, '.6f'))

					print(first_price)
					
					for a, b in zip(prices[::1], prices[1::1]):
						pdiff=100 * (b - a) / a
			
					pdiff=round(pdiff,2)

					coin_stats=''
					coin_stats=coin_stats+"\n<b>:: Current Ticker For: "+str(ticker_symbol)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: 24 Low: '+str(low)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: 24 High: '+str(high)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: Bid: '+str(bid)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: Ask: '+str(ask)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: Last: '+str(ask)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: First Alert Price: '+str(first_price)+'</b>'+"\n"
					coin_stats=coin_stats+'<b>:: Price Diff Since First Alert: '+str(price_diff)+'('+str(pdiff)+'%)</b>'+"\n"

					csymbol=ticker_symbol
					csymbol=csymbol.replace("/","_",1)
					link='https://www.binance.com/en/trade/pro/'+csymbol

					coin_stats=coin_stats+':: '+str(link)

					message=message+"\n"+coin_stats
					if seen==1:
						bot.send_message(chat_id=update.message.chat_id, text=message, parse_mode= 'HTML')

def botstats(bot, update, args):
	
	config = configparser.ConfigParser()

	config.read('/root/akeys/b.conf')
	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	conn=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cur = conn.cursor()
	
	all=int(1)
	dates=int(0)
	
	if args:
		count=len(args)
		print(str(count))
		if count>1:
			start_date=args[1].upper()


			if start_date=='TODAY':
				from datetime import datetime, timedelta

				query="select * from at_analysis where date=current_date"
				today=datetime.strftime(datetime.now(), '%Y-%m-%d')
				start_date=today
				end_date=today
				print("SD: "+str(start_date))
				print("ED: "+str(end_date))
			elif start_date=='YESTERDAY':
			
				from datetime import datetime, timedelta
				yesterday=datetime.strftime(datetime.now() - timedelta(1), '%Y-%m-%d')
				query="select * from at_analysis where date='"+str(yesterday)+"'"
				start_date=yesterday
				end_date=yesterday
			elif count==3:
				start_date=args[1]
				end_date=args[2]
				query="select * from at_analysis where date>='"+str(start_date)+"'and date<='"+str(end_date)+"'"
				dates=int(1)

		if args[0]!='':
			trade_to=str(args[0].upper())
			all=int(0)
			
			if trade_to!='ALL':
				query=query+" and trade_to='"+trade_to+"'"	
	else:
		query="select * from at_analysis"
	
	print(query)
	cur.execute(query)
	conn.commit()
	result = cur.fetchall()
	
	for row in result:
		id=row[0]
		date=row[1]
		start_date_time=row[2]
		end_date_time=row[3]
		start_timestamp=int(row[4])
		end_timestamp=int(row[5])
		duration_secs=int(row[6])
		bot_id=int(row[7])
		order_id=str(row[8])
		symbol=str(row[9])	
		rsi_symbol=str(row[10])
		trade_from=str(row[11])
		trade_to=str(row[12])
		units=float(row[13])
		buy_price=float(row[14])
		sell_price=float(row[15])
		profit=float(row[16])
		profit_percent=float(row[17])
		bot_profit_high=float(row[18])			
		bot_profit_high_percent=float(row[19])			
		invest_start=float(row[20])
		invest_end=float(row[21])
	
		message=":::BOT " +str(symbol)
		message=message+"\nSTART TIME: "+str(start_date_time)
		message=message+"\nEND TIME: "+str(end_date_time)
		message=message+"\nRAN FOR: "+str(duration_secs)+" SECS"	
		message=message+str("\nBUY PRICE: ")+str(buy_price)+"\nSELL PRICE: "+str(sell_price)+"\nUNITS: "+str(units)
		message=message+"\nVALUE START: "+str(invest_start)
		message=message+"\nVALUE END: "+str(invest_end)
		message=message+"\nP&L: "+str(profit)+' ('+str(profit_percent)+'%)'
		message=message+"\nP&L HIGHS: "+str(bot_profit_high)+' ('+str(bot_profit_high_percent)+'%)'
		message=message+"\nBOT ID: "+str(bot_id)
		message=message+"\nORDER ID: "+str(order_id)
		
		print(message)
		bot.send_message(chat_id=update.message.chat_id, text=message,parse_mode= 'HTML')	
		
def botcsv(bot, update, args):
	
	config = configparser.ConfigParser()

	config.read('/root/akeys/b.conf')
	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	conn=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cur = conn.cursor()
	
	all=int(1)
	dates=int(0)

	if args:
		
		argstr=' '.join(args[0:])
		parser = argparse.ArgumentParser()
				
		parser.add_argument('--start', help='Start Date')
		parser.add_argument('--end', help='End Date')
		parser.add_argument('--to', help='Trading To I.e BTC')
		
		
		pargs = parser.parse_args(shlex.split(argstr))

		
		end_date=str(pargs.end)
		trade_to=str(pargs.to)
		
		count=len(args)
		print(str(count))
		if count>1:
			start_date=str(pargs.start.upper())
			#start_date=args[1].upper()

			if start_date=='TODAY':
				from datetime import datetime, timedelta

				query="select * from at_analysis where date=current_date"
				today=datetime.strftime(datetime.now(), '%Y-%m-%d')
				start_date=today
				end_date=today
				print("SD: "+str(start_date))
				print("ED: "+str(end_date))
			elif start_date=='YESTERDAY':
			
				from datetime import datetime, timedelta
				yesterday=datetime.strftime(datetime.now() - timedelta(1), '%Y-%m-%d')
				query="select * from at_analysis where date='"+str(yesterday)+"'"
				start_date=yesterday
				end_date=yesterday
			elif count==3:
				start_date=str(pargs.start.upper())
				end_date=str(pargs.end.upper())
				#start_date=args[1]
				#end_date=args[2]
				query="select * from at_analysis where date>='"+str(start_date)+"'and date<='"+str(end_date)+"'"
				dates=int(1)

		if args[0]!='':
			#trade_to=str(args[0].upper())
			trade_to=str(pargs.to.upper())
			all=int(0)
			
			if trade_to!='ALL':
				query=query+" and trade_to='"+trade_to+"'"	
	else:
		query="select * from at_analysis"
	
	print(query)
	cur.execute(query)
	conn.commit()
	result = cur.fetchall()
	
	csv=str("Date\tStart DT\tEnd DT\tBot ID\tOrder ID\tTrading Pair\tTrade From\tTrade To\tUnits\tBuy Price\tSell Price\tProfit\tProfit Percent\tInvest Start\tInvest End\tDuration High Profit\tDuration High Percent\tDuration Secs")
	for row in result:
		id=row[0]
		date=row[1]
		start_date_time=row[2]
		end_date_time=row[3]
		start_timestamp=int(row[4])
		end_timestamp=int(row[5])
		duration_secs=int(row[6])
		bot_id=int(row[7])
		order_id=str(row[8])
		symbol=str(row[9])	
		rsi_symbol=str(row[10])
		trade_from=str(row[11])
		trade_to=str(row[12])
		units=float(row[13])
		buy_price=float(row[14])
		sell_price=float(row[15])
		profit=float(row[16])
		profit_percent=float(row[17])
		bot_profit_high=float(row[18])			
		bot_profit_high_percent=float(row[19])			
		invest_start=float(row[20])
		invest_end=float(row[21])
	
		csv=csv+"\n"+str(date)+"\t"+str(start_date_time)+"\t"+str(end_date_time)+"\t"+str(bot_id)+"\t"+str(order_id)+"\t"+str(symbol)+"\t"+str(trade_from)+"\t"+str(trade_to)+"\t"+str(units)+"\t"+str(buy_price)+"\t"+str(sell_price)+"\t"+str(profit)+"\t"+str(profit_percent)+"\t"+str(invest_start)+"\t"+str(invest_end)+"\t"+str(bot_profit_high)+"\t"+str(bot_profit_high_percent)+"\t"+str(duration_secs)
		message=":::BOT " +str(symbol)
		message=message+"\nSTART TIME: "+str(start_date_time)
		message=message+"\nEND TIME: "+str(end_date_time)
		message=message+"\nRAN FOR: "+str(duration_secs)+" SECS"	
		message=message+str("\nBUY PRICE: ")+str(buy_price)+"\nSELL PRICE: "+str(sell_price)+"\nUNITS: "+str(units)
		message=message+"\nVALUE START: "+str(invest_start)
		message=message+"\nVALUE END: "+str(invest_end)
		message=message+"\nP&L: "+str(profit)+' ('+str(profit_percent)+'%)'
		message=message+"\nP&L HIGHS: "+str(bot_profit_high)+' ('+str(bot_profit_high_percent)+'%)'
		message=message+"\nBOT ID: "+str(bot_id)
		message=message+"\nORDER ID: "+str(order_id)
		
		print(csv)
	
	csv=csv+"\n"
	f= open("/home/crypto/cryptologic/csvs/stats.csv","w+")
	f.write(csv)
		
	chat_id=update.message.chat_id
	bot.send_document(chat_id=chat_id, document=open('/home/crypto/cryptologic/csvs/stats.csv', 'rb'))
	#bot.send_document(chat_id=chat_id, document=open('tests/test.zip', 'rb'))


def list_bots(bot, update, args):
	
	botlist=r.smembers("botlist")
	exchange=nickbot.get_exchange()
	percent=int(0)
	if not botlist:
		message="Currently there are no bots running"
		bot.send_message(chat_id=update.message.chat_id, text=message,parse_mode= 'HTML')	
		return(1)
	
	for bot_name in botlist:
		bot_name=bot_name.decode('utf-8')
		symbol=bot_name
		buy_array=""
		buy_price=int(0)
		market_price=int(0)
		units=int(0)
		investment_start=int(0)
		investment_now=int(0)
		print(symbol)
		
		orders = exchange.fetch_open_orders(symbol,1)
		open_order=len(orders)
		if open_order:
			message="Theres an open order for: "+str(symbol)
			bot.send_message(chat_id=update.message.chat_id, text=message,parse_mode= 'HTML')
			continue
		new_stoploss=0
		ts=float(r.get(bot_name))
		running=datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")
		redis_key="bconfig-"+symbol		
		last_stoploss=0
		all=r.hgetall(redis_key)
		
		trade_from=r.hget(redis_key,'trade_from').decode('utf-8')
		trade_to=r.hget(redis_key,'trade_to').decode('utf-8')
		book_pos=int(0)
		wall_stoploss=int(0)
		if r.hget(redis_key,"book_pos"):
			book_pos=r.hget(redis_key,"book_pos").decode('utf-8')
		
		if r.hget(redis_key,"wall_stoploss"):
			wall_stoploss=r.hget(redis_key,"wall_stoploss").decode('utf-8')

		bot_id=r.hget(redis_key,'id').decode('utf-8')
		
		ts=float(r.get(bot_name).decode('utf-8'))				
		running=datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")				
		
		key=str(symbol)+'-TRADES'	
		key=str(symbol)+'-LAST-PRICE'
		if r.get(key):
			market_price=float(r.get(key))

		t_key="TTT-"+str(symbol)
		buy_array=nickbot.fetch_last_buy_order(exchange,symbol)

		print("SLDB: "+str(symbol))
		
		print(buy_array)
		
		profit_total=int(0)
		if buy_array!='NULL':
			units=float(buy_array['executedQty'])
			
			if buy_array['type']=='MARKET':
				print(buy_array)	
				buy_price=float(buy_array['cummulativeQuoteQty'])/units
				print("DB1: "+str(buy_price))
			else:
				buy_price=float(buy_array['price'])
				print("DB2: "+str(buy_price))

			profit_per_unit=market_price-buy_price
			profit_total=float(profit_per_unit*units)
			profit_total=round(profit_total,8)
			prices = [buy_price,market_price]
			for a, b in zip(prices[::1], prices[1::1]):
				percent=100 * (b - a) / a
				percent=round(percent,2)

			investment_start=units*buy_price
			investment_now=units*market_price	
		
			investment_now=float(investment_now)
			investment_now=round(investment_now,8)
	
		message="<b>:::BOT " +str(symbol)+"\nSTARTED: </b>"+str(running)+str("\n<b>BUY PRICE:</b> ")+str(buy_price)+"\n<b>PRICE NOW:</b> "+str(market_price)+"\n<b>UNITS:</b> "+str(units)
		vol24=float(nickbot.volume24h_in_usd(symbol))
		message=message+"\n<b>VOLUME 24HRS:</b> "+str(vol24)
		message=message+"\n<b>VALUE START:</b> "+'('+str(trade_to)+'): '+str(investment_start)
		message=message+"\n<b>VALUE NOW:</b> "+'('+str(trade_to)+'): '+str(investment_now)
		message=message+"\n<b>P&L:</b> "+str(profit_total)+' ('+str(percent)+'%)'
		message=message+"\n<b>BOT ID:</b> "+str(bot_id)
	
		ckey=str(bot_id)+'-CPS'
		
		if r.hget(ckey,"checkpoints"):
			checkpoint_stoploss=float(r.hget(ckey, 'checkpoint_stoploss').decode('utf-8'))
			checkpoints=int(r.hget(ckey, 'checkpoints').decode('utf-8'))
			message=message+"\n<b>LAST CHECKPOINT STOPLOSS:</b> "+str(checkpoint_stoploss)
			message=message+"\n<b>CHECKPOINTS:</b> "+str(checkpoints)
			message=message+"\n<b>BOOK POSITION:</b> "+str(book_pos)
			buy_ratio=str(r.get('SENT-BUYS').decode('utf-8'))
			sell_ratio=str(r.get('SENT-SELLS').decode('utf-8'))
			price_up_ratio=str(r.get('SENT-PRICE-UP-RATIO').decode('utf-8'))
			message=message+"\n<b>SENTIMENT RATIO OF BUYS:</b> "+str(buy_ratio)
			message=message+"\n<b>SENTIMENT RATIO OF SELLS:</b> "+str(sell_ratio)
			message=message+"\n<b>SENTIMENT PRICE UP RATIO:</b> "+str(price_up_ratio)
		
		key=str(symbol)+'-SYSTEM-STOPLOSS'
			
		if mc.get(key):
			last_stoploss=mc.get(key)		
			print("SLP LAST STOPLOSS: "+str(last_stoploss))
			print("SLP NEW STOPLOSS: "+str(new_stoploss))
			
		bot.send_message(chat_id=update.message.chat_id, text=message,parse_mode= 'HTML')	
		
def stoploss(bot, update,args):	
	symbol=args[0].upper()
	action=str(args[1].lower())

	mc = memcache.Client(['127.0.0.1:11211'], debug=0)	

	if action=="execute":
	
		key=str(symbol)+'-SLTMP'
		stoploss_price=mc.get(key)			
		
		key=str(symbol)+'-BBTMP'
		buyback_price=mc.get(key)

		message=":::SYSTEM EXECUTED A STOPLOSS OF: "+str(stoploss_price)+" WITH BUYBACK PRICE OF: "+str(buyback_price)
		bot.send_message(chat_id=update.message.chat_id, text=message)

		key=str(symbol)+'-SYSTEM-STOPLOSS'
		mc.set(key,stoploss_price,86400)			
		
		#key=str(symbol)+'-SYSTEM-BUYBACK'
		#mc.set(key,buyback_price,864)			

		return(1)
	else:
		stoploss_percent=float(args[1].lower())
		buyback_percent=float(args[2].lower())

		exchange=nickbot.get_exchange()
		
		if float(stoploss_percent)>0:
			bid=update.message.from_user.id
			price=nickbot.get_price(exchange,symbol)
	
			ret=nickbot.exchange.fetch_closed_orders (symbol, 1);
			if ret:
				data=ret[-1]['info']
				side=data['side']
				units=float(data['executedQty'])
				last_price=float(data['price'])

				profit=price-last_price
				profit=profit*units
				prices = [last_price,price]
				for a, b in zip(prices[::1], prices[1::1]):
					percent=100 * (b - a) / a

				percent=round(percent,2)
				profit=round(profit,2)
				profit=price-last_price
				profit=profit*units
				prices = [last_price,price]
				for a, b in zip(prices[::1], prices[1::1]):
					percent=100 * (b - a) / a

				percent=round(percent,2)
				profit=round(profit,2)

				stoploss=price/100*stoploss_percent
				stoploss_price=price-stoploss

				buyback=stoploss_price/100*buyback_percent
				buyback_price=stoploss_price-buyback

				message=str(symbol)+" Price: "+str(price)+" Last Price: "+str(last_price)+" Units: "+str(units)+" Profit: "+str(profit)+' ('+str(percent)+'%)'
		
				stoploss_info=("::::STOPLOSS INFO::::\nSetting a stoploss % of: "+str(stoploss_percent)+" % Would have a stoploss price of "+str(stoploss_price)+"\nReply With /stoploss execute to execute changes")
		
				buyback_info=("::::BUYBACK INFO::::\nSetting a byback % of: "+str(buyback_percent)+" % Would have a buyback price of "+str(buyback_price)+"\nReply With /stoploss execute to execute changes")

				message=str(message)+"\n"+str(stoploss_info)+str(buyback_info)
		
				key=str(symbol)+'-SLTMP'
				mc.set(key,stoploss_price,86400)			
		
				key=str(symbol)+'-BBTMP'
				mc.set(key,buyback_price,86400)			
		
				bot.send_message(chat_id=update.message.chat_id, text=message)


def price(bot, update,args):	
	symbol=args[0].upper()
	
	exchange=nickbot.get_exchange()

	bid=update.message.from_user.id
	price=nickbot.get_price(exchange,symbol)
	
	ret=exchange.fetch_closed_orders (symbol, 1);
	if ret:
		data=ret[-1]['info']
		side=data['side']
		units=float(data['executedQty'])
		print(data)
		last_price=float(data['price'])
		
		profit=price-last_price
		profit=profit*units
		prices = [last_price,price]
		for a, b in zip(prices[::1], prices[1::1]):
			percent=100 * (b - a) / a

		percent=round(percent,2)
		profit=round(profit,2)

		message=str(symbol)+" Price: "+str(price)+" Last Price: "+str(last_price)+" Units: "+str(units)+" Profit: "+str(profit)+' ('+str(percent)+'%)'
		bot.send_message(chat_id=update.message.chat_id, text=message)

dispatcher = updater.dispatcher
start_handler = CommandHandler('start', help)
help_handler = CommandHandler('help', help)
ticker_handler = CommandHandler('ticker', ticker,pass_args=True)
p_handler = CommandHandler('p', ticker,pass_args=True)
market_handler = CommandHandler('market', market)
tether_handler=CommandHandler('tether', tether,pass_args=True)
untether_handler=CommandHandler('untether', untether,pass_args=True)
price_handler=CommandHandler('price', price,pass_args=True)
stoploss_handler=CommandHandler('stoploss', stoploss,pass_args=True)
list_bots_handler=CommandHandler('listbots', list_bots,pass_args=True)
add_bot_handler=CommandHandler('addbot', add_bot,pass_args=True)
delete_bot_handler=CommandHandler('deletebot', delete_bot,pass_args=True)
alerts_handler=CommandHandler('alerts', alerts,pass_args=True)
cashout_handler = CommandHandler('cashout', cashout,pass_args=True)
walls_handler = CommandHandler('walls', walls,pass_args=True)
book_intel_handler = CommandHandler('bookintel', bookintel,pass_args=True)
bot_stats_handler = CommandHandler('botstats', botstats,pass_args=True)
bot_csv_handler = CommandHandler('botcsv', botcsv,pass_args=True)

dispatcher.add_handler(delete_bot_handler)
dispatcher.add_handler(add_bot_handler)
dispatcher.add_handler(start_handler)
dispatcher.add_handler(stoploss_handler)
dispatcher.add_handler(list_bots_handler)
dispatcher.add_handler(ticker_handler)
dispatcher.add_handler(market_handler)
dispatcher.add_handler(help_handler)
dispatcher.add_handler(tether_handler)
dispatcher.add_handler(untether_handler)
dispatcher.add_handler(untether_handler)
dispatcher.add_handler(price_handler)
dispatcher.add_handler(p_handler)
dispatcher.add_handler(alerts_handler)
dispatcher.add_handler(cashout_handler)
dispatcher.add_handler(walls_handler)
dispatcher.add_handler(book_intel_handler)
dispatcher.add_handler(bot_stats_handler)
dispatcher.add_handler(bot_csv_handler)
updater.start_polling()
import os
import sys, argparse
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import redis
import configparser
from datetime import datetime
import subprocess
import heapq
import nickbot

redis_key="bconfig-"+bot_name
	


all_keys = list(r.hgetall(redis_key))
bot_id=all_keys["id"].decode('utf-8')

#r.delete(ckey)
#r.hdel(ckey)
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402
import nickbot

redis_server = redis.Redis(host='localhost', port=6379, db=0)

def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

exchange=nickbot.get_exchange()	

config = configparser.ConfigParser()

config.read('/root/akeys/b.conf')
mysql_username=config['mysql']['MYSQL_USERNAME']
mysql_password=config['mysql']['MYSQL_PASSWORD']
mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
mysql_database=config['mysql']['MYSQL_DATABASE']

print(mysql_hostname)
print(mysql_username)
print(mysql_password)
print(mysql_database)

db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)

try:
	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
except Exception:
	print("Error in MySQL connexion")
else:
	cur = db.cursor()
	
	subcur = db.cursor()

	subquery="truncate at_analysis";
	subcur.execute(subquery)
	
	#try:
	query='select * from at_orders'
	cur.execute(query)
	##except Exception:
	#	print("Error with query: " + query)
	#else:
	db.commit()
	result = cur.fetchall()
	for row in result:
		id=row[0]
		date=row[1]
		end_date_time=str(row[2])
		end_timestamp=int(row[3])
		bot_id=row[4]
		order_id=row[5]
		symbol=row[6]
		rsi_symbol=row[7]
		trade_from=row[8]
		trade_to=row[9]
		units=row[10]
		buy_price=row[11]
		sell_price=row[12]
		profit=row[13]
		profit_percent=row[14]
		
		subquery="select date_time,timestamp,total_invest from at_history where bot_id="+str(bot_id)+" limit 1"
		subcur.execute(subquery)
		subresult = subcur.fetchall()
		for srow in subresult:
			start_date_time=str(srow[0])
			start_timestamp=srow[1]
			invest_start=srow[2]
			invest_end=invest_start+profit
	
		subquery="select profit,profit_percent from at_history where bot_id="+str(bot_id)+" order by profit_percent desc limit 1";
		subcur.execute(subquery)
		subresult = subcur.fetchall()
		for srow in subresult:
			bot_profit_high=srow[0]
			bot_profit_high_percent=srow[1]
			
		print("Start Date: "+str(start_date_time))
		print("End Date: "+str(end_date_time))
		
		day1=str(start_date_time)
		day2=str(end_date_time)
		day1=datetime.datetime(*time.strptime(day1, "%Y-%m-%d %H:%M:%S")[:6])
		day2=datetime.datetime(*time.strptime(day2, "%Y-%m-%d %H:%M:%S")[:6])
		duration_secs=str(abs(day2-day1).seconds)
		print(duration_secs)

		sql = str("""INSERT INTO at_analysis(date,start_date_time,end_date_time,start_timestamp,end_timestamp,duration_secs,bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent,bot_profit_high,bot_profit_high_percent,invest_start,invest_end) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)""")
		subcur.execute(sql,(date,start_date_time,end_date_time,start_timestamp,end_timestamp,duration_secs,bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent,bot_profit_high,bot_profit_high_percent,invest_start,invest_end))


	db.close() 
import os
import sys
import json
from operator import itemgetter
import re
import memcache
import codecs
import logging
import sys
import pymysql
import time
import requests
import re
import configparser
import datetime
import redis
import heapq
import nickbot

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['LD_LIBRARY_PATH'] = '/usr/local/lib'
sys.path.append(root + '/python')

import talib
import numpy as np
import ccxt  # noqa: E402

def log_db(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,bid,last,ask,open,close,high,low,bot_id):

	key=str(symbol)+'-SYSTEM-STOPLOSS'
	if mc.get(key):
		stoploss_price=float(mc.get(key))
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	market_price=float(close)
	
	profit_per_unit=market_price-buy_price
	profit=float(profit_per_unit*units)
	profit=round(profit,8)
	prices = [buy_price,market_price]
	for a, b in zip(prices[::1], prices[1::1]):
		profit_percent=100 * (b - a) / a
		profit_percent=round(profit_percent,2)

	total_invest=units*buy_price
	total_now=units*market_price	

	total_now=float(total_now)
	total_now=round(total_now,8)

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = """
		INSERT INTO at_history(date,date_time,timestamp,symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low,bot_id)
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	"""
	print(sql)
	cursor.execute(sql,(symbol,rsi_symbol,trade_from,trade_to,buy_price,units,stoploss_price,profit,profit_percent,total_invest,total_now,bid,last,ask,open,close,high,low,bot_id))
	db.close()

def log_order(exchange,bot_id,order_id,order_type,symbol,rsi_symbol,trade_from,trade_to,sell_price,units):
	
	config = configparser.ConfigParser()
	config.read('/root/akeys/b.conf')

	mysql_username=config['mysql']['MYSQL_USERNAME']
	mysql_password=config['mysql']['MYSQL_PASSWORD']
	mysql_hostname=config['mysql']['MYSQL_HOSTNAME']
	mysql_database=config['mysql']['MYSQL_DATABASE']

	order_array=nickbot.fetch_last_buy_order(exchange,symbol)
	buy_price=float(order_array['price'])
	
	profit_per_unit=sell_price-buy_price
	profit=float(profit_per_unit*units)
	profit=round(profit,8)
	prices = [buy_price,sell_price]
	for a, b in zip(prices[::1], prices[1::1]):
		profit_percent=100 * (b - a) / a
		profit_percent=round(profit_percent,2)

	db=pymysql.connect(mysql_hostname,mysql_username,mysql_password,mysql_database)
	cursor = db.cursor()
	
	sql = str("""
		INSERT INTO at_orders(date,date_time,timestamp,bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent) 
		VALUES (CURRENT_DATE(),NOW(),UNIX_TIMESTAMP(),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
	""")

	print(bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent)

	cursor.execute(sql,(bot_id,order_id,symbol,rsi_symbol,trade_from,trade_to,units,buy_price,sell_price,profit,profit_percent))
	db.close()
	
r = redis.Redis(host='localhost', port=6379, db=0)

def fetch_prices(exchange, symbol):
	ticker = exchange.fetch_ticker(symbol.upper())
	return(ticker)


def replace_last(source_string, replace_what, replace_with):
    head, _sep, tail = source_string.rpartition(replace_what)
    return head + replace_with + tail

def volume24h_in_usd(symbol):

	exchange=nickbot.get_exchange()

	symbol=symbol.upper()
	ticker_symbol=symbol
	tickers=fetch_prices(exchange,ticker_symbol)

	v24=tickers['quoteVolume']

	if symbol.endswith('BTC'):
		tickers=fetch_prices(exchange,'BTC/USDT')
		trade_to_price=float(tickers['close'])
	elif symbol.endswith('ETH'):
		tickers=fetch_prices(exchange,'ETH/USDT')
		trade_to_price=float(tickers['close'])
	elif symbol.endswith('BNB'):
		tickers=fetch_prices(exchange,'BNB/USDT')
		trade_to_price=float(tickers['close'])
	else:
		trade_to_price=1

	p24=v24*trade_to_price
	p24=float(p24)
	
	return(p24)

def price_usd(symbol):

	symbol=symbol.upper()
	ticker_symbol=symbol

	exchange=nickbot.get_exchange()

	if symbol.endswith('BTC'):
		ticker_symbol = replace_last(ticker_symbol, '/BTC', '')
		trade_to='BTC'
	elif symbol.endswith('USDT'):
		ticker_symbol = replace_last(ticker_symbol, '/USDT', '')
		trade_to='USDT'
	elif symbol.endswith('BNB'):
		ticker_symbol = replace_last(ticker_symbol, '/BNB', '')
		trade_to='BNB'
	elif symbol.endswith('TUSD'):
		ticker_symbol = replace_last(ticker_symbol, '/TUSD', '')
		trade_to='TUSD'
	elif symbol.endswith('USD'):
		ticker_symbol = replace_last(ticker_symbol, '/USD', '')
		trade_to='USD'
	elif symbol.endswith('USDC'):
		ticker_symbol = replace_last(ticker_symbol, '/USDC', '')
		trade_to='USDC'
	elif symbol.endswith('PAX'):
		ticker_symbol = replace_last(ticker_symbol, '/PAX', '')
		trade_to='PAX'
	elif symbol.endswith('USDS'):
		ticker_symbol = replace_last(ticker_symbol, '/USDS', '')
		trade_to='USDS'
	elif symbol.endswith('ETH'):
		ticker_symbol = replace_last(ticker_symbol, '/ETH', '')
		trade_to='ETH'
	
	trade_from=ticker_symbol
	exchange=nickbot.get_exchange()
	
	pair_price=0
	budget=1
	if trade_to=='ETH':
		tickers=fetch_prices(exchange,'ETH/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	elif trade_to=='BTC':
		tickers=fetch_prices(exchange,'BTC/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	elif trade_to=='BNB':
		tickers=fetch_prices(exchange,'BNB/USDT')
		trade_to_price=float(tickers['close'])
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])
		fraction_to_budget=budget/trade_to_price
		units=fraction_to_budget/pair_price
		pair_price=budget/units
	else:
		tickers=fetch_prices(exchange,symbol)
		pair_price=float(tickers['close'])

	print(tickers)
	pair_price=float(pair_price)
	return(pair_price)

#exchange=get_exchange()
def get_price(exchange,symbol):
	
	symbol=symbol.upper()	
	ticker = exchange.fetch_ticker(symbol.upper())
	print(str(ticker))
	price=float(ticker['last'])
	return(price)

def wall_pos2(symbol,usd_limit):
	
	#Fucking jedi master shit, lets make sure that theres usd_limit above us in the buy book @ set our dynamic stoploss at that
	usd_limit=float(usd_limit)
	pusd=float(price_usd(symbol))
	exchange=nickbot.get_exchange()
	message=""
	buy_book=exchange.fetch_order_book(symbol,1000)
	print(buy_book)
	pos=int(0)
	book=buy_book['bids']
	print(book)
	#book.reverse()
	tv_usd=0
	got=0
	print("USD LIMIT: "+str(usd_limit))
	for line in book:
		k=line[0]
		v=line[1]
		v_usd=round(float(v)*pusd,2)
		tv_usd=round(float(tv_usd+v_usd),2)
		#print("DEBUG K: "+str(k))
		#print("DEBUG TVUSD: "+str(tv_usd))
		#print("DEBUG USDLIMIT: "+str(usd_limit))
		#if k>=float(stoploss):
		message=message+"BOOK POS: "+str(pos)+"\tPRICE: "+str(k)+"\tVOLUME: "+str(v)+"\tVOLUME USD: "+str(v_usd)+"\tTOTAL VOLUME USD: "+str(tv_usd)+"\n"
		print(message)
		if tv_usd>=usd_limit:
			print(message)
			return(pos)
			got=1	
		
		if got!=1:
			pos+=1
			
	return(pos)		
	print(message)


exchange=nickbot.get_exchange()

#nickbot.wall_pos('BTC/USDT','100000')
#print("BNB/USDT:")
#new_stoploss=float(nickbot.wall_magic('BNB/USDT','11000'))
#print("ETH/USDT:")
#new_stoploss=float(nickbot.wall_magic('ETH/USDT','11000'))
print("CMT/BTC:")
new_stoploss=float(nickbot.wall_magic('CMT/BTC','11000'))
trades=exchange.fetchTrades ('CMT/BTC')
c=0
for dat in trades:
	ts=dat['timestamp']	
	if c==0:
		start_ts=ts/1000
	last_ts=ts/1000
	c+=1
elapsed = last_ts - start_ts
elapsed=elapsed/60
print(elapsed)
#print(trades)
sys.exit("die")
def walls(symbol):
	
	#symbol=args[0].upper()
	exchange=nickbot.get_exchange()
	
	buy_book=exchange.fetch_l2_order_book(symbol,500)
	sell_book=exchange.fetch_l2_order_book(symbol,500)
	print(buy_book)
	buy_dic={}
	sell_dic={}
	
	for k,v in buy_book:
		buy_dic[k]=v
		print(v)
		print("Key: "+str(k)+" v: "+str(v))

	for k,v in sell_book:
		sell_dic[k]=v
				
	buy_walls=heapq.nlargest(20, buy_dic.items(), key=itemgetter(1))
	print(buy_walls)
	sell_walls=heapq.nlargest(20, sell_dic.items(), key=itemgetter(1))
	
	message="<b>WALL INTEL:</b>\n\n"
	
	message=message+"<b>BUY WALLS ('SUPPORT')</b>\n"
	
	for k,v in sorted(buy_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"

	message=message+"\n<b>SELL WALLS ('RESISTANCE')</b>'\n"
	for k,v in sorted(sell_walls):
		message=message+"<b>PRICE:</b> "+str(k)+"\t<b>VOLUME:</b> "+str(v)+"\n"
	
	print(message)
		
walls('BTC/PAX')